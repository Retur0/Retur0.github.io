{"meta":{"title":"Retur0's Bolg","subtitle":null,"description":null,"author":"Retur0","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-07-19T22:41:00.000Z","updated":"2020-02-29T02:31:20.183Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T22:36:44.000Z","updated":"2020-02-29T02:31:30.756Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2020.7 | bug汇总#1","slug":"bug汇总1","date":"2020-07-07T09:30:20.000Z","updated":"2020-07-07T09:37:07.914Z","comments":true,"path":"2020/07/07/bug汇总1/","link":"","permalink":"http://yoursite.com/2020/07/07/bug%E6%B1%87%E6%80%BB1/","excerpt":"【日期】：2020/4/9 【问题】：报错“java:不支持发行版本5”。 【原因】：jdk 版本被 maven 项目配置覆盖，需要在 pom 中指定 jdk 版本。 【如何发现】：maven 项目 build 时报错。 【如何修复】：在 pom 中添加： 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;13&lt;/source&gt; &lt;target&gt;13&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 【总结】：maven 配置可能会覆盖 idea 配置。","text":"【日期】：2020/4/9 【问题】：报错“java:不支持发行版本5”。 【原因】：jdk 版本被 maven 项目配置覆盖，需要在 pom 中指定 jdk 版本。 【如何发现】：maven 项目 build 时报错。 【如何修复】：在 pom 中添加： 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;13&lt;/source&gt; &lt;target&gt;13&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 【总结】：maven 配置可能会覆盖 idea 配置。 【日期】：2020/4/11 【问题】：IDEA 连接 MySQL 数据库出现时区问题。 【原因】：MySQL 默认时区是 UTC（世界标准时间）。 【如何发现】：IDEA 连接数据库时报错。 【如何修复】：找到 MySQL的 my.ini 配置文件，在 [mysqlid] 下添加一行：default-time-zone=’+08:00’。使 IDEA 与 MySQL 时区一致。 【总结】：MySQL 默认时区为 UTC。 【日期】：2020/5/20 【问题】：maven 无法下载。 【原因】：使用了阿里云的镜像，协议为 https，IDEA 会检查证书，访问被 IDEA 拦下。 【如何发现】：新建项目时 maven 出错。 【如何修复】：settings/Maven/Importing 下，VM options for importer 设置为 -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true。效果是不限制证书。之后删除 repository 中的所有文件，重新下载。 【总结】：IDEA 会检查访问 https 协议链接的证书。 【日期】：2020/5/28 【问题】：8080端口被占用。 【原因】：Oracle 监听服务会使用8080端口。 【如何发现】：使用 netatat -ano 命令查看端口使用情况，找到占用8080端口程序的PID。使用 tasklist 命令显示计算机上所有进程，发现上面找到的PID对应的程序为 TNSLSNR.exe，即 Oracle 监听程序。 【如何修复】：先打开 Tomcat，再开监听服务。 【总结】：Oracle 监听服务默认使用8080端口。 【日期】：2020/6/5 【问题】： A ResourcePool could not acquire a resource from its primary factory or source. 【原因】：Tomcat 的 lib 下没有 Ojdbc。 【如何发现】：SSM 项目在请求读数据库卡在执行 SQL 语句。 【如何修复】：把 Ojdbc 的包复制到 Tomcat 的 lib 下。 【总结】：造成这个错误的原因还有在配置数据库的时候出错。记得当时学习 MySql 数据库时我跟着视频，做了把 mysql-connector-java 放到 lib 下的工作。但是有的同学没有做，就访问不到数据库。现在我也在同样的地方卡住了哈哈。","categories":[{"name":"bug汇总","slug":"bug汇总","permalink":"http://yoursite.com/categories/bug%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"汇总","slug":"汇总","permalink":"http://yoursite.com/tags/%E6%B1%87%E6%80%BB/"}]},{"title":"数据结构与算法笔记（1）——稀疏数组、队列","slug":"数据结构与算法笔记（1）——稀疏数组、队列","date":"2020-07-07T09:23:42.000Z","updated":"2020-07-07T09:26:52.192Z","comments":true,"path":"2020/07/07/数据结构与算法笔记（1）——稀疏数组、队列/","link":"","permalink":"http://yoursite.com/2020/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E3%80%81%E9%98%9F%E5%88%97/","excerpt":"稀疏数组当一个数组中大部分元素是0，或者为同一个值的数组时，可以用稀疏数组来保存该数组。","text":"稀疏数组当一个数组中大部分元素是0，或者为同一个值的数组时，可以用稀疏数组来保存该数组。 稀疏数组的处理方法是： 记录数组一共有几行几列，有多少个不同的值。 把具有不同值的元素的行列和值记录在一个小规模的数组中，从而缩小程序的规模。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static void main(String[] args) &#123; // 定义二维数组 int chessArr[][] = new int[11][11]; chessArr[1][2] = 1; chessArr[2][3] = 2; // 遍历二维数组获得非零数据的个数 int sum = 0; for (int i = 0; i &lt; 11; i++)&#123; for (int j = 0; j &lt; 11; j++)&#123; if(chessArr[i][j] != 0) sum++; &#125; &#125; // 创建对应的稀疏数组 int sparseArr[][] = new int[sum+1][3]; // 给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; // 遍历二维数组，将非零值存放到稀疏数组中 int count = 0; // count用于记录是第几个非零数据 for (int i = 0; i &lt; 11; i++)&#123; for (int j = 0; j &lt; 11; j++)&#123; if(chessArr[i][j] != 0)&#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr[i][j]; &#125; &#125; &#125; for(int i = 0; i &lt; sparseArr.length; i++)&#123; System.out.printf(\"%d\\t%d\\t%d\\t\\n\", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); &#125; // 稀疏数组恢复成二维数组 int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]]; for(int i = 1; i &lt; sparseArr.length; i++)&#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; for (int i = 0; i &lt; 11; i++)&#123; for (int j = 0; j &lt; 11; j++)&#123; System.out.print(chessArr2[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; 队列 队列是一个有序列表，可以用数组或是链表实现。 先入先出。 用 maxSize 表示队列的最大容量，front 表示队列元素前一位的下标，rear 表示队列最后一位的下标。 front 随着数据的取出而改变，rear 随着数据加入而改变。 为了解决目前数组使用一次就不能用的问题，使用取模算法改进成一个环形的队列。 环形队列环形队列中，front指向队列的第一个元素，初始值=0。rear指向队列中最后一个元素的后一个位置，初始值=0。 队列满的条件为：(rear + 1) % maxSize == front 队列空的条件为：rear == front 对类中有效数据的个数：(rear + maxSize - front) % maxSize 我们可以发现无论在哪种队列中，front 和 rear 不能同时指向第一个元素和最后一个元素。这样是因为，在队列中只有一个元素时，避免 front 和 rear 相等，出现无法判断队列空的情况。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package cn.Retur0;public class ArrayQueue &#123; public static void main(String[] args) &#123;// Queue q = new Queue(3);// q.add(10);// q.add(20);// q.add(30);// q.show();// System.out.println(q.get());// System.out.println(q.get());// q.show(); CircleQueue cq = new CircleQueue(4);//最大4，实际容量为3 cq.add(10); cq.add(20); cq.add(30); cq.show(); System.out.println(); cq.get(); cq.show(); System.out.println(); cq.add(40); cq.show(); &#125;&#125;//编写Queue类class Queue &#123; private int maxSize; private int front; private int rear; private int[] arr; public Queue(int maxSize) &#123; this.maxSize = maxSize; front = -1; rear = -1; arr = new int[maxSize]; &#125; public boolean isFull() &#123; return rear == maxSize - 1; &#125; public boolean isEmpty() &#123; return front == rear; &#125; public void add(int n) &#123; if (isFull()) &#123; throw new RuntimeException(\"队列已满\"); &#125; arr[++rear] = n; &#125; public int get() &#123; if (isEmpty()) &#123; throw new RuntimeException(\"队列已空\"); &#125; return arr[++front]; &#125; public void show() &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); &#125; &#125;&#125;//编写环形队列类class CircleQueue &#123; private int maxSize; private int front; // 环形队列中front指向队列的第一个元素，初始值=0 private int rear; // rear指向队列中最后一个元素的后一个位置，初始值=0 private int[] arr; public CircleQueue(int maxSize) &#123; this.maxSize = maxSize; arr = new int[maxSize]; front = 0; rear = 0; &#125; public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; public boolean isEmpty() &#123; return front == rear; &#125; public void add(int n) &#123; if (isFull()) &#123; throw new RuntimeException(\"队列已满\"); &#125; arr[rear] = n; rear = (rear + 1) % maxSize; &#125; public int get() &#123; if (isEmpty()) &#123; throw new RuntimeException(\"队列已空\"); &#125; int temp = arr[front]; front = (front + 1) % maxSize; return temp; &#125; public void show() &#123; for (int i = front; i &lt; front + size(); i++) &#123; System.out.printf(\"arr[%d]=%d\\n\", i % maxSize, arr[i % maxSize]); &#125; &#125; // 环形队列中有效数据的个数 public int size() &#123; return (rear + maxSize - front) % maxSize; &#125;&#125;","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SpringMVC异常处理","slug":"SpringMVC异常处理","date":"2020-05-24T06:42:04.000Z","updated":"2020-05-25T01:43:22.044Z","comments":true,"path":"2020/05/24/SpringMVC异常处理/","link":"","permalink":"http://yoursite.com/2020/05/24/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"1 异常处理思路Controller 调用 service，service 调用 dao，异常都是向上抛出的，最终由 Dispatcher Servlet 找出异常处理器进行异常的处理。","text":"1 异常处理思路Controller 调用 service，service 调用 dao，异常都是向上抛出的，最终由 Dispatcher Servlet 找出异常处理器进行异常的处理。 2 SpringMVC 的异常处理正常的处理流程： 浏览器 –&gt; 前端控制器 –&gt; web –&gt; service –&gt; dao 发生异常后： dao –&gt; service –&gt; web –&gt; 前端控制器 –&gt; 异常处理器 –&gt; 浏览器 编写自定义异常类（做提示信息的） 编写异常处理类 配置异常处理类（跳转到提示） 自定义异常类 SysException.java 1234567891011121314151617181920/** * 自定义异常类 */public class SysException extends Exception&#123; // 存储提示信息 private String message; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public SysException(String message) &#123; this.message = message; &#125;&#125; 编写异常处理类 SysExceptionResolver.java 123456789101112131415161718192021222324252627282930/** * 异常处理器 */public class SysExceptionResolver implements HandlerExceptionResolver &#123; /** * 处理异常 * @param request * @param response * @param handler * @param ex * @return */ @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; // 获取到异常对象 SysException e = null; if(ex instanceof SysException)&#123; e = (SysException)ex; &#125;else&#123; e = new SysException(\"系统正在维护...\"); &#125; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"errorMsg\",e.getMessage()); mv.setViewName(\"error\"); return mv; &#125;&#125; 在 SpringMVC.xml 中配置： 12&lt;!--配置异常处理器--&gt;&lt;bean id=\"sysExceptionResolver\" class=\"cn.Retur0.SysExceptionResolver\"/&gt;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/categories/SpringMVC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Git远程操作","slug":"Git远程操作","date":"2020-05-24T02:58:10.000Z","updated":"2020-05-25T01:43:29.805Z","comments":true,"path":"2020/05/24/Git远程操作/","link":"","permalink":"http://yoursite.com/2020/05/24/Git%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C/","excerpt":"1 本地库与远程库交互方式项目创建者 通过 push 将项目放在远程库中托管。 项目创建者 通过 pull 将远程库中的项目拉取到本地。 项目参与者 通过 clone 将远程库中的项目拉取到本地。 项目参与者 通过 push 将本地项目更新到远程库。","text":"1 本地库与远程库交互方式项目创建者 通过 push 将项目放在远程库中托管。 项目创建者 通过 pull 将远程库中的项目拉取到本地。 项目参与者 通过 clone 将远程库中的项目拉取到本地。 项目参与者 通过 push 将本地项目更新到远程库。 流程： 使用 add 和 commit 命令创建 working tree clean 地本地库。 git remote add origin https://给网址起别名为 origin。 git remote -v查看所有远程地址别名。 git push [别名] [分支名]推送。 1.1 克隆git clone https:// 完整地把远程库下载到本地。 创建 origin 远程地址别名。 初始化本地库。 1.2 成员 要想加入一个合作者，需要在 github 的 setting/collaborators 中添加合作者的账号，并让这个合作者接收邀请。之后合作者的 push 就不会有问题了。 1.3 抓取更改后的远程库git fetch origin master 抓取之后并不会立刻更改工作区的文件。抓取的文件保存在 origin/master 分支上。确定抓取的远程库没有问题后，使用 git merge origin/master 来将抓取的库融合到本地库。此时工作区才会改变。 pull = fetch + merge。如果直接 pull 就无法确认他人做出的修改是否合理。 2 解决冲突如果不是基于 Github 远程库的最新版所做的修改，不能推送，必须先拉取。","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git命令行操作","slug":"Git命令行操作","date":"2020-05-22T02:54:45.000Z","updated":"2020-05-22T02:56:37.669Z","comments":true,"path":"2020/05/22/Git命令行操作/","link":"","permalink":"http://yoursite.com/2020/05/22/Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/","excerpt":"1 基本操作 本地库初始化 命令：git init 效果：在当前目录下创建 .git 文件夹。 注意：.git 目录放的是本地库相关的子目录和文件，不要删除，也不要胡乱修改。","text":"1 基本操作 本地库初始化 命令：git init 效果：在当前目录下创建 .git 文件夹。 注意：.git 目录放的是本地库相关的子目录和文件，不要删除，也不要胡乱修改。 设置签名 签名是用来标识不同开发人员的身份。包括用户名和 email。要注意登录代码托管中心（远程库）的账号密码和签名没有任何关系。 命令： git config user.name Retur0 git config user.email 384878281@qq.com 项目级别/仓库级别：仅在当前本地库范围内有效。 git config --global 系统用户级别：登录操作系统的用户范围。 优先级：项目级别优先于系统用户级别。没有项目级别则以用户级别的签名为准。 用户信息保存到了 .git/config 文件里。 系统用户级别的信息存在了用户文件夹下的 .gitconfig 文件里。~/.gitconfig 状态查看操作 命令：git status 可以查看工作区、暂存区的状态。 添加操作 命令：git add [file name] 将工作区的新建/修改添加到暂存区。 提交操作 命令：git commit -m &quot;commit message&quot; [file name] 将暂存区的内容提交到本地库。 显示日志/查看历史纪录 命令： git log 参数： –pretty=oneline 以每条日志显示一行的形式打印日志。 –oneline 哈希值显示一部分，更加简短。只显示到当前版本。不加参数是显示所有版本。 git reflog 显示现版本到历史版本需要移动的次数。 版本的前进后退 命令： git reset --hard [局部索引值] git reset --hard HEAD^^^ 3个^倒退3个版本。只能后退。 git reset --hard HEAD~3 倒退三个版本。只能后退。 参数： –soft 只在本地库移动指针。（本地库回退到某个版本） –mixed 在本地库移动指针。（本地库回退到某个版本） 重置暂存区。（暂存区回退到某个版本） –hard 在本地库移动指针。（本地库回退到某个版本） 重置暂存区。（暂存区回退到某个版本） 重置工作区。（工作区回退到某个版本） 删除文件并找回 删除前，文件需要被提交到过本地库。 命令：git reset --hard [局部索引值] 比较文件差异 命令： git diff [文件名] 将工作区中的文件和暂存区中进行比较。 git diff [本地库中的历史版本] [文件名] 将工作区中的文件和某个历史版本进行比较。 2 分支管理在版本控制过程中，使用多条线同时推进多个任务。提高开发效率。在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。 2.1 分支操作： 创建分支 git branch [分支名] 查看分支 git branch -v 切换分支 git checkout [分支名] 合并分支：必须切换到接受修改的分支上。 git merge [有新内容的分支] 2.2 解决合并时产生的冲突如果两分支同一文件的同一行不同，则会产生冲突。此时需要手动解决冲突。 冲突后文件如下： 9 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 10 hhhhhhhhhhhh edit by hot_fix 11 ======= 12 hhhhhhhhhhhh edit by master 13 &gt;&gt;&gt;&gt;&gt;&gt;&gt; master HEAD到=======是当前分支的内容，=======下面是合并进来分支的内容。删除重复的，保留需要的。 之后使用git add [文件名]提交修改好的文件。 使用git commit -m &quot;日志信息&quot;结束 merging 状态。这里不可以带文件名。","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"SpringMVC详解","slug":"SpringMVC详解","date":"2020-05-18T08:24:58.000Z","updated":"2020-05-18T08:26:38.030Z","comments":true,"path":"2020/05/18/SpringMVC详解/","link":"","permalink":"http://yoursite.com/2020/05/18/SpringMVC%E8%AF%A6%E8%A7%A3/","excerpt":"4 常用注解4.1 RequestParam为了解决 请求参数名称 和 方法参数名称 不同的问题。可以将两个名称匹配起来。 属性：","text":"4 常用注解4.1 RequestParam为了解决 请求参数名称 和 方法参数名称 不同的问题。可以将两个名称匹配起来。 属性： value：请求参数名称。 required：请求参数中是否必须提供此参数。默认值：true，表示必须提供，不提供就报错。 12345@RequestMapping(\"/testRequestParam\")public String testServlet(@RequestParam(value=\"name\") String username)&#123; System.out.println(username); return \"success\";&#125; 4.2 RequestBody用于获取请求体内容。直接使用得到的是 key=value&amp;key=value… 结构的数据。get请求方式没有请求体。 异步时传输 json 数据会有用。 属性： required：是否必须要有请求体。默认值：true。true时 get 请求会报错，false 时 get 请求得到的是 null。 12345@RequestMapping(\"/testRequestBody\")public String testRequestBody(@RequestBody String body)&#123; System.out.println(body); return \"success\";&#125; 4.3 PathVariable用于绑定 url 中的占位符。例如：请求 url 中的 /delete/{id}，{id}就是占位符。 属性： value：用于指定 url 中占位符名称。 required：时候必须提高占位符。 RESTful 风格 URL： REST，Representational State Transfer。描述了一个架构样式的网络系统，比如 Web 应用程序。 在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。值得注意的是REST并没有一个明确的标准，而更像是一种设计的风格。 12345@RequestMapping(\"/testPathVariable/&#123;sid&#125;\")public String testPathVariable(@PathVariable(value=\"sid\") String id)&#123; System.out.println(id); return \"success\";&#125; 4.4 RequestHeader用于获取请求消息头。 属性： value：提供消息头名称。 required：是否必须有此消息头。 12345@RequestMapping(\"/testRequestHeader\")public String testRequestHeader(@RequestHeader(value=\"User-Agent\") String header)&#123; System.out.println(header); return \"success\";&#125; 4.5 CookieValue用于获取指定 Cookie 名称的值。 属性： value：提供 Cookie 名称。 required：是否必须有此 Cookie。 12345@RequestMapping(\"/testCookieValue\")public String testCookieValue(@CookieValue(value=\"JSESSIONID\") String cv)&#123; System.out.println(cv); return \"success\";&#125; 4.6 ModelAttribute可以加在方法和参数上。 出现在方法上，表示当前方法会在控制器方法之前执行。 出现在参数上，获取指定的数据给参数赋值。 属性： value：用于获取数据的 key。可以是 POJO 的属性名称，也可以是 map 结构的 key。 4.7 SessionAttributes用于多次执行控制器方法间的参数共享。 属性： value：用于指定存入的属性名称。 type：用于指定存入的数据类型。 5 响应数据和结果视图5.1 返回字符串方法中，可以在 model 对象里添加属性，使得添加的属性可以在返回页面中用 EL 读到。就完成了后台取到数据传回去前端。 5.2 返回 void如果返回 void，则方法执行完之后的跳转页面是 请求路径.jsp 。 12345678910@RequestMapping(\"/testVoid\")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; // 编写请求转发 request.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(request,response); // 重定向 response.sendRedirect(request.getContextPath()+\"/xxx.jsp\") return;&#125; 5.3 返回 ModelAndView 对象这个对象是由 SpringMVC 提供的，可以用来调整具体的 JSP 视图。 1234567891011121314151617181920// 返回 ModelAndView 对象，可以传入视图的名称（即跳转的页面），还可以传入对象。@RequestMapping(\"/testModelAndView\")public ModelAndView testModelAndView()&#123; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); // 模拟从数据库中查询User对象 User user = new User(); user.setUserName(\"name01\"); user.setPassword(\"123456\"); user.setAge(20); // 把user对象存储到mv对象中，也会把user对象存到request对象中 mv.addObject(\"user\",user); // 跳转到哪个页面 mv.setViewName(\"success\"); return mv;&#125; 5.4 使用关键字进行转发或重定向在方法的返回值使用return &quot;forward:/WEB-INF/pages/success.jsp&quot;表明想使用请求转发。 重定向：return &quot;redirect:/index.jsp&quot;。这里不需要加项目名，因为框架已经帮我们做好了。","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/categories/SpringMVC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC基础","slug":"SpringMVC基础","date":"2020-05-12T01:21:53.000Z","updated":"2020-05-12T01:25:33.491Z","comments":true,"path":"2020/05/12/SpringMVC基础/","link":"","permalink":"http://yoursite.com/2020/05/12/SpringMVC%E5%9F%BA%E7%A1%80/","excerpt":"1 SpringMVCM – model，模型。JavaBean。 V – View，JSP。JSP，HTML。 C – Controller，控制器。Servlet。 1.1 简介SpringMVC 是一种基于 java，实现了 MVC 设计模型的请求驱动型轻量级 Web 框架，属于 Spring FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring框架提供了构建 Web应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 Web 开发时，可以使用 SpringMVC 来代替其他 MVC 开发框架，如Struts2。","text":"1 SpringMVCM – model，模型。JavaBean。 V – View，JSP。JSP，HTML。 C – Controller，控制器。Servlet。 1.1 简介SpringMVC 是一种基于 java，实现了 MVC 设计模型的请求驱动型轻量级 Web 框架，属于 Spring FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring框架提供了构建 Web应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 Web 开发时，可以使用 SpringMVC 来代替其他 MVC 开发框架，如Struts2。 1.2 入门程序创建一个 Maven 项目，选择webapp。注意是 maven 的 webapp，不是 cocoon 的webapp。 在创建时添加下面这个键值对可以让创建变快： Maven 的 pom.xml 中添加以下依赖： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.2.3.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; web.xml 1234567891011121314151617181920212223&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"cn.Retur0\"/&gt; &lt;!--视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--开启SpringMVC框架注解的支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; index.jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门程序&lt;/h3&gt; &lt;a href=\"hello\"&gt;进入&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; success.jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;成功&lt;/body&gt;&lt;/html&gt; Hello.java 12345678@Controllerpublic class Hello &#123; @RequestMapping(path=\"/hello\") public String sayHello()&#123; System.out.println(\"Hello,springMVC\"); return \"success\"; &#125;&#125; 项目结构如下： 1.3 总结一下流程 启动服务器，加载配置文件。 加载 web.xml，DispatcherServlet 对象被创建。 在创建 DispatcherServlet 对象时，参数加载 springmvc.xml。 springmvc.xml 中配置的开启注解扫描，会让配置注解的 Hello 类和方法实例化（默认单例）为对象，加载到 IoC 容器中。 加载视图解析器对象，它可以帮我们完成页面跳转的功能。 发送请求，后台处理请求。 SpringMVC 框架是基于组件方式执行流程。 DispatcherServlet：前端控制器 用户请求到达前端控制器，它相当于 MVC 模式中的 C，是整个控制流程的中心，由它调用其他组件处理用户的请求，它的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器 HandlerMapping 负责根据用户请求 找到 Handler 即处理器，SpringMVC 提供了不同映射器是先不用的映射方式，例如：配置文件方式，实现接口方式，注解方式。 Handler：处理器 开发中需要编写的具体业务控制器。控制器将用户请求转发到处理器。由处理器对具体的用户请求进行处理。 HandlerAdapter：处理器适配器 通过 HandlerAdapter 对处理器进行执行，这个是是配置模式的应用。通过扩展适配器可以对更多类型的处理器进行执行。 ViewResolver：视图解析器 负责处理结果生成的 View 视图，它首先根据逻辑视图明解析成物理视图名即具体的页面地址，在生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给客户。 View：视图 SpringMVC 框架提供了很多的 View 试图类型的支持，包括：jstlVIew、freemarkerView、pdfView。一般情况下需要通过页面标签或页面模板技术讲模型数据通过页面展示给用户需要由程序员根据业务需求开发具体的页面。 1.4 RequestMapping 注解用于建立请求 URL 和处理请求方法之间的对应关系。 这个注解不仅可以放到方法上，也可以放到类上。放到类上的路径为一级目录。请求时需要/一级/二级。有利于模块化开发。 属性：对访问进行一些限制。 path/value：可以互换。意义相同。如果只有一个属性的话，也可以不写属性名。 @RequestMapping(&quot;/testResquestMapping&quot;) method：规定这个方法可以被什么请求方式请求到。它可以的取值是一个枚举类。 @RequestMapping(value=&quot;/testResquestMapping&quot;, method={RequestMethod.POST}) params：限定在请求时必须要同时传递的参数。它的取值是一个字符串数组。 @RequestMapping(value=&quot;/testResquestMapping&quot;, params={&quot;username=name&quot;,&quot;password&quot;}) 在超链接的href末尾需要加 ? 跟两个参数，多个参数用 &amp; 连接。参数的名称和值都必须和注解中定义的一样。 headers：发送的请求中必须包括的请求头。 2 请求参数的绑定2.1 说明表单提交的数据都是 k=v 格式的。SpringMVC的参数绑定是把表单提交的请求参数，作为控制器中方法的参数进行绑定的。要求提交表单的 name 和参数的名称是相同的。 如果方法的参数名和请求的参数名相同，框架自动把参数传入方法。 底层通过反射来实现。 支持的数据类型： 基本数据类型和字符串类型。 提交表单的 name 和参数的名称是相同的。并且区分大小写。 实体类型（JavaBean）。 提交表单的 name 和 JavaBean 中的属性名称需要一致。 如果一个 JavaBean 类中包含其他的引用类型，那么表单的 name 属性需要编写成对象.属性。 集合类型。页面上的编写方式：list[0].属性 123456789101112131415161718192021222324252627282930313233&lt;body&gt; 提交参数： &lt;a href=\"paramBinding?name=name01&amp;password=123456\"&gt;发送参数&lt;/a&gt;&lt;br&gt; &lt;br&gt; 提交JavaBean对象：把数据封装到Account类中 &lt;form action=\"beanParamBinding\" method=\"post\"&gt; 账户名称：&lt;input type=\"text\" name=\"username\" /&gt;&lt;br&gt; 密码：&lt;input type=\"text\" name=\"password\" /&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\" /&gt;&lt;br&gt; 姓名：&lt;input type=\"text\" name=\"User.name\" /&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"User.age\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"发送JavaBean参数\"/&gt;&lt;br&gt; &lt;/form&gt; &lt;br&gt; 提交集合类型：把数据封装到Account类中，类中有list和map集合 &lt;form action=\"beanParamBinding\" method=\"post\"&gt; 账户名称：&lt;input type=\"text\" name=\"username\" /&gt;&lt;br&gt; 密码：&lt;input type=\"text\" name=\"password\" /&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\" /&gt;&lt;br&gt; 传入user的数据&lt;br&gt; 姓名：&lt;input type=\"text\" name=\"User.name\" /&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"User.age\" /&gt;&lt;br&gt; 传入list的数据&lt;br&gt; 姓名：&lt;input type=\"text\" name=\"list[0].name\" /&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"list[0].age\" /&gt;&lt;br&gt; 传入map的数据&lt;br&gt; 姓名：&lt;input type=\"text\" name=\"map['one'].name\" /&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"map['one'].age\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交集合类型\"/&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt; 1234567891011@RequestMapping(path=\"/paramBinding\")public String paramBinding(String name, String password)&#123; System.out.println(name + \"______\" + password); return \"success\";&#125;@RequestMapping(\"/beanParamBinding\")public String beanParamBinding(Account acc)&#123; System.out.println(acc); return \"success\";&#125; 2.2 中文乱码问题传统解决方法是request.setChar。SpringMVC已经封装了这个方法，通过过滤器对请求中的中文字符进行转码。 在 web.xml 中配置过滤器。(过滤器可能要写在 Servlet 上面) 123456789&lt;!--配置中文转码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.3 自定义类型转换器涉及到一些类型如日期时，网页提交字符串的格式很可能不是能被Date识别的格式，这时候就需要类型转换器来解决这个问题。 通过实现 Converter 接口来自定义数据类型转换器。 Converter&lt;S, T&gt;：S-&gt;source数据源，T-&gt;target目标。 12345678910public calss stringToDateConverter implements Converter&lt;String,Date&gt;&#123; public Date convert(String source)&#123; DataFormat df = new SimpleDateFormat(\"yyyy-MM-dd\"); try&#123; return df.parse(source); &#125; catch (Exception e)&#123; throw new RuntimeException(\"数据类型转换出现错误\"); &#125; &#125;&#125; 在 SpringMVC 中添加配置： 123456789&lt;bean id=\"conversionServcieFactoryBean\" class=\"ConversionServcieFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;bean class=\"cn.Retur0.utils.StringToDateConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;mvc:annotation-driven conversion-service=\"conversionServcieFactoryBean\"/&gt; 3 获取原生 Servlet API在方法的参数部分添加 request 和 response。 1234567@RequestMapping(\"/testServlet\")public String testServlet(HttpServletRequest request, HttpServletResponse)&#123; System.out.println(request); System.out.println(response); HttpSession session = request.getSession(); ServletContext servletContext = session.getServletContext();&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/categories/SpringMVC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"WebService","slug":"WebService","date":"2020-05-09T01:32:50.000Z","updated":"2020-05-09T01:37:06.030Z","comments":true,"path":"2020/05/09/WebService/","link":"","permalink":"http://yoursite.com/2020/05/09/WebService/","excerpt":"1 WebService的概述与应用场景1.1 简介 web服务，它是一种跨编程语言和跨操作系统平台的远程调用技术，即跨平台远程调用技术。 WebService是一个平台独立的，低耦合的，自包含的，基于可编程的web应用程序。使用开放的xml标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。 为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。","text":"1 WebService的概述与应用场景1.1 简介 web服务，它是一种跨编程语言和跨操作系统平台的远程调用技术，即跨平台远程调用技术。 WebService是一个平台独立的，低耦合的，自包含的，基于可编程的web应用程序。使用开放的xml标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。 为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。 1.2 应用场景 2 WebService 的标准和实现方式2.1 标准采用标准SOAP(Simple Object Access Protocol)协议传输，soap属于w3c标准。soap协议是基于http的应用层协议，soap协议传输的是xml数据。soap协议就是标签的格式。 2.2 方式 采用wsdl(web service description language) 作为描述语言，wsdl属于w3c标准。 xml是webservice跨平台的基础，因为它既与平台无关，又与厂商无关。 XSD，w3c为webservice制定了一套传输数据类型，使用xml进行描述，即XSD(XML Schema Datatypes)，任何编程语言写的webservice接口在发送数据时都要转换成XSD发送。就是一种xml约束。 WebService数据传输的方式： SOAP：http + xml。 Http rest：一套用来创建webService的方法，REST式的webservice使用http里的方法：get, post, delete, put。 http 自定义数据协议：比如http传输json协议，http传输xml数据等。 3 WebService 开发规范Java中共有3种 WebService 开发规范 JAX-WS（JAX-RPC）、JAXM &amp; SAAJ 、JAX-RS。 3.1 JAX-WS 概述全称为 Java API for XML-Based WebService，Java提供了一个jar包来实现WebService。 JDK1.5 ~ JAX-WS 2.0 JDK1.6.0_13 ~ JAX-WS 2.1 JDK1.7 ~ JAX-WS 2.2 4 JAX-WS4.1 提供一个查询天气的WebService接口创建项目，创建一个SEI(Service Endpoint Interface)接口，本质是一个Weather接口。 com.Retur0.weather.WeatherInterface 123public interface WeatherInterface&#123; public String queryWeather(String cityName); &#125; 实现天气接口，在类上添加@WebService注解。 WeatherInterfaceImpl 1234567891011@WebServicepublic class WeatherInterfaceImpl inplements WeatherInterface&#123; @Override public String queryWeather(String cityName)&#123; if(\"河北\".equals(cityName))&#123; return cityName + \":14~25摄氏度\"; &#125;else&#123; return cityName + \": no data\"; &#125; &#125;&#125; 发布服务： 12345public class Main&#123; public static void main(String[] args)&#123; Endpoint.publish(\"http://127.0.0.1/12345/\", new WeatherInterfaceImpl); &#125;&#125; 此时在浏览器访问本地的12345端口就可以看到WebService服务。（JDK6) 4.2 wsdl 说明书Web Services Description Language，网络服务描述语言。下面是其中的一些标签。 &lt;service&gt; 服务视图，webservice的服务节点，它包括了服务端点。 &lt;binding&gt; 为每个服务端点定义消息格式和协议细节。 &lt;portType&gt; 服务端点，描述webservie可被执行的操作方法，以及相关的消息，通过binging指向portType。 &lt;message&gt; 定义一个操作（方法）的数据参数（可有多个参数）。 &lt;types&gt; 定义webservice使用的全部数据类型。 4.3 阅读方法从下往上阅读，先找到服务视图，通过binging找到portType，找到了protType就找到了WebService方法。 4.4 Wsimport 命令JDK自带的WebService工具，可以根据wsdl文档生成 Java 代码。位于JAVA_HOME/bin目录下。 常用参数： -s&lt;目录&gt; 生成.java文件。 -d&lt;目录&gt; 生成.class文件。默认参数。 -p&lt;新生成的包名&gt; 将生成的类放于指定的包下。 (wsdlurl) - htttp://server:port/service?wsdl 必须的参数。 示例： C:/wsimport -s . htttp://server:1234/weather?wsdl 4.5 通过Wsimport生成客户端调用类保证服务端开启，之后用cmd进入客户端java项目的src目录，输入： wsimport -keep -d D:\\temp\\d -s D:\\temp\\s -p com.map -verbose http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl 完成之后src下就会出现通过wsimport生成的客户端调用类。 4.6 WebService客户端编写 创建服务窗口。 通过服务对象找到服务端点。 调用WebService的方法。 main.java 12345678public class Main&#123; public static void main(String[] args)&#123; WeatherInterfaceImplService service = new WeatherInterfaceImplService(); WeatherInterImpl port = service.getPort(WeatherInterfaceImpl.class); String weatherInfo = prot.queryWeather(\"河北\"); System.out.println(weatherInfo); &#125;&#125; 5 ApacheCXF 框架实现 WebService（Jax-ws)5.1 服务端使用到的依赖包有：cxf-rt-frontend-jaxws、cxf-rt-transports-http-jetty（服务器）、junit、log4j。 定义业务接口并实现： HelloImpl.java 123456public class HelloImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return name + \", welcome\"; &#125;&#125; 发布服务： 1234567891011121314public class Server &#123; public static void main(String[] args)&#123; // 发布服务的工厂 JaxWsServerFactoryBean factory = new JaxWsServerFactoryBean(); // 设置服务地址 factory.setAddress(\"http://localhost:8000/ws/hello\"); // 设置服务类 factory.setServiceBean(new HelloImpl()); // 发布服务 factory.create(); System.out.println(\"发布成功，端口：8000\"); &#125;&#125; 5.2 客户端客户端需要有服务接口的java文件。 获取服务，Client.java: 12345678910111213141516171819202122public class Client &#123; public static void main(String[] args) &#123; // 服务接口访问地址:http://localhost:8000/ws/hello // 创建cxf代理工厂。可以对接口生成代理对象，通过代理对象远程访问服务端。 JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean(); // 设置远程访问服务端地址 factory.setAddress(\"http://localhost:8000/ws/hello\"); // 设置接口类型 factory.setServiceClass(HelloService.class); // 对接口生成代理对象 HelloService hs = (HelloService) factory.create(); System.out.println(hs.getClass()); // 远程访问服务端方法 System.out.println(hs.sayHello(\"Joe\")); &#125;&#125; 6 例子：获取手机归属地服务先用 wsimport 命令在项目里生成需要的类和接口： 1wsimport -s [想要存放的路径] http:&#x2F;&#x2F;ws.webxml.com.cn&#x2F;WebServices&#x2F;MobileCodeWS.asmx?wsdl Client.java 1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; // 创建cxf代理工厂。可以对接口生成代理对象，通过代理对象远程访问服务端。 JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean(); // 设置远程访问服务端地址 factory.setAddress(\"http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl\"); // 设置接口类型 factory.setServiceClass(MobileCodeWSSoap.class); // 对接口生成代理对象 MobileCodeWSSoap mcw = (MobileCodeWSSoap) factory.create(); // System.out.println(mcw.getClass()); // 远程访问服务端方法 System.out.println(mcw.getMobileCodeInfo(\"15832318651\",\"\")); &#125;&#125; 成功在控制台获得号码归属地。","categories":[{"name":"WebService","slug":"WebService","permalink":"http://yoursite.com/categories/WebService/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"WebService","slug":"WebService","permalink":"http://yoursite.com/tags/WebService/"}]},{"title":"MyBatis更多操作","slug":"MyBatis更多操作","date":"2020-05-05T06:18:13.000Z","updated":"2020-05-05T06:20:06.701Z","comments":true,"path":"2020/05/05/MyBatis更多操作/","link":"","permalink":"http://yoursite.com/2020/05/05/MyBatis%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C/","excerpt":"5 SqlMapConfig.xml 配置文件5.1 配置内容SqlMapConfig.xml 中配置的内容和顺序如下： properties（属性） settings（全局配置参数） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） enviornments（环境集合对象属性） enviorment（环境子属性对象） transactionManager（事务管理） dataSource（数据源） mappers（映射器）","text":"5 SqlMapConfig.xml 配置文件5.1 配置内容SqlMapConfig.xml 中配置的内容和顺序如下： properties（属性） settings（全局配置参数） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） enviornments（环境集合对象属性） enviorment（环境子属性对象） transactionManager（事务管理） dataSource（数据源） mappers（映射器） 5.2 properties可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息。 内部：通过在 ${} 中写 properties 中的 name 值，来引用 value 值。 12345678910111213141516171819202122&lt;properties&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mbdemo\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"password\"/&gt;&lt;/properties&gt;&lt;!--配置环境--&gt;&lt;environments default=\"mysql\"&gt; &lt;!--配置mysql环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源/连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的4个基本信息--&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 外部：resource 属性用于指定配置文件的位置，必须按照类路径的写法来写，并且必须存在于类路径下。 ${} 中的属性名必须与配置文件中的一致。 123456789101112131415161718&lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt;&lt;!--配置环境--&gt;&lt;environments default=\"mysql\"&gt; &lt;!--配置mysql环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源/连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的4个基本信息--&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; resource 属性也可以用 url 属性替代，在这里可以用 file 协议写 url 值： url=&quot;file:///C:User/Desktop/jdbc.properties&quot; 在这个路径中不能有中文。 5.3 typeAliases使用 typeAliases 配置别名，它只能配置 domain 类中的别名。type 属性指的是实体类全限定类名。alias 属性指定别名，指定别名后不区分大小写。 123&lt;typeAliases&gt; &lt;typeAlias type=\"cn.Retur0.domain.User\" alias=\"user\"&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; 这样指定当多了会很麻烦，所以可以指定package。 指定之后，该包下的实体类都会注册别名，并且类名就是别名，不区分大小写。 123&lt;typeAliases&gt; &lt;package name=\"cn.Retur0.domain\"&gt;&lt;/package&gt;&lt;/typeAliases&gt; 5.4 mappers这里面也有一个 package 标签。用于指定 dao 接口所在的包，当指定了之后就不需要再写 resouce class 或mapper 了。 123&lt;mappers&gt; &lt;package name=\"cn.Retur0.dao\"&gt;&lt;/package&gt;&lt;/mappers&gt; 6 连接池与事务控制6.1 连接池我们在实际开发中会使用连接池，因为它可以减少我们获取连接的时间。 连接池就是用于存储链接的一个容器。容器其实是一个集合对象。该集合必须是线程安全的，不能两个线程拿到同一个连接。该集合还实现了队列的特性：先进先出。 6.2 MyBatis 中的连接池MyBatis 连接池提供了3种配置的方式。配置的位置在 SqlMapConfig.xml 中 dataSource 标签的 type 属性，type属性表示采用何种连接池方式。 type 属性的取值： POOLED 采用传统的 javax.sql.DataSouce 规范中的连接池，MyBatis 中有针对规范的实现。 UNPOOLED 采用传统的获取连接的方式，虽然也实现 javax.sql.DataSouce 接口，但是并没有使用池的思想。 JNDI 采用服务器提供的 JNDI 技术实现，来获取 DataSouce 对象。不同的服务器能拿到的 DataSource 服务器也是不一样的。（如果不是 web 或者 maven 的 war 工程，是不能使用的）例如 tomcat 服务器，采用的是 dbcp 连接池。 在 POOLED 模式下获取连接的流程： 连接池分为空闲池和活动池。如果空闲池还有连接的话，直接拿一个来用。 如果空闲池中没有连接可用，则到活动池中看看是否已经到了最大数量。若没到最大数量，则在活动池中创建一个新的连接。 若活动池中的连接已达到最大数量，则把活动池中连接时间最长的连接返回回去。 很明显在开发中使用 POOLED。 6.3 事务 什么是事务：指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务的四大特性 ACID：原子性，隔离性，持久性，一致性。 不考虑隔离性会产生的三个问题：脏读，重复度，幻读。 解决办法：四种隔离级别。读未提交，读提交，重复读，幻读。 在 MyBatis 中，它是通过 sqlsession 对象的 commit() 方法和 rollback() 方法实现事务的提交和回滚。 7 动态SQL可以在 sql 语句的查询标签里添加&lt;if/&gt;&lt;where/&gt;&lt;foreach/&gt;标签实现动态查询。 8 多表操作MyBatis 中把 多对一 看成由多个 一对一 组成的。 一对多 用户与订单 一对多 多对一 一对一 人和身份证号 多对多 老师与学生 MyBatis 中的多表查询： 用户与账户：一个用户可以有多个账户，一个账户只能对应一个用户（多个账户属于同一个用户）。 步骤： 建立两张表：用户表，账户表。 让用户表和账户表具备一对多的关系，需要使用外键在账户表中添加。 建立两个实体类：用户实体类和账户实体类。 让用户和账户能的实体类体现出一对多的关系。 建立两个配置文件： 用户的配置文件 账户的配置文件 实现配置： 当我们查询用户时，可以得到用户下的所有账户信息。 当我们查询账户时，可以同时得到账户的所属用户信息。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Mybatis基础使用","slug":"Mybatis基础使用","date":"2020-04-14T05:51:10.000Z","updated":"2020-04-17T10:59:23.216Z","comments":true,"path":"2020/04/14/Mybatis基础使用/","link":"","permalink":"http://yoursite.com/2020/04/14/Mybatis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"1 MyBatis简介1.1 MyBatiesMyBaties 是一个优秀的持久层框架。它对jdbc的操作数据库的过程进行封装，使开发者只需要关注SQL本身，而不需要花精力处理例如注册驱动、创建connection、创建statemen手动设置参数、结果集检索等jdbc繁杂的过程代码。","text":"1 MyBatis简介1.1 MyBatiesMyBaties 是一个优秀的持久层框架。它对jdbc的操作数据库的过程进行封装，使开发者只需要关注SQL本身，而不需要花精力处理例如注册驱动、创建connection、创建statemen手动设置参数、结果集检索等jdbc繁杂的过程代码。 MyBaties 通过 xml 或注解的方式将要执行的各种 statement（statement、prepareStatement、CallableStatement）配置起来。并通过 java 对象和 statement 中的 SQL 进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL 并将节果映射成 java 对象并返回。 使用ORM思想实现对象关系映射。也就是实体类中的属性和数据库表的字段名保持一致。 1.2 MyBatis 的框架核心 MyBatis 配置文件，包括 MyBatis 全局配置文件和 MyBatis 映射文件，其中全局配置文件配置了数据源、事务等信息，映射文件配置了SQL执行相关的信息。 MyBatis 通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory，即会话工厂。 通过 SqlSessionFactory，可以创建 SqlSession 即会话。Mybatis 是通过 SqlSession 来操作数据库的。 SqlSession 本身并不能直接操作数据库，它是通过底层的 Executor 执行器接口来操作数据库的。Executor 接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。 Executor 执行器要处理的 SQL 信息是封装到一个底层对象 MappedStatement 中。该对象包括：SQL语句、输入参数映射信息、输出就过集映射信息。曲中输入参数和输出节果的映射类型包括 Java的简单类型、HashMap集合对象、POJO对象类型。 2 MyBatis 开始2.1 开发步骤 创建maven工程并导入目标。 创建实体类和dao接口。 创建MyBatis的主配置文件 SqlMapConfig.xml。 创建映射配置文件 IUserDao.xml。 创建POJO类12345678public class User implements Serializable&#123; private int id; private String username; private String sex; private Date birthday; private String address; // 以及属性的getter和setter&#125; 创建dao层1234567package cn.Retur0.dao;import cn.Retur0.domain.User;import java.util.List;public interface IUserDao &#123; List&lt;User&gt; findAll();&#125; 创建全局配置文件SqlMapConfig.xml在src下，创建 SqlMapConfig.xml 文件。 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源/连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的4个基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mbdemo\"/&gt;&lt;!--?serverTimezone=UTC--&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"password\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"cn/Retur0/dao/IUserDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 为单个dao创建配置文件IUserDao.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.Retur0.dao.IUserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"cn.Retur0.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 2.2 注意事项 IUserDao.xml 也可以起名为 IUserMapper.xml。 映射文件必须与接口文件目录结构相同。 映射配置文件的 mapper 标签 namesapce 属性的取值必须是 dao 接口的全限定类名。 映射配置文件的操作配置（select 标签），id属性的取值为 dao 中的方法名。 遵从2 3 4 点之后，在开发中就不需要写 dao 的实现类了。 2.3 运行test.java 12345678910111213141516171819202122232425262728293031323334353637package cn.Retur0;import cn.Retur0.dao.IUserDao;import cn.Retur0.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;public class test &#123; public static void main(String[] args) throws Exception&#123; // 读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建SqlSessionFactory工厂 SqlSessionFactoryBuilder bulider = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = bulider.build(in); // 使用工厂创建SqlSession对象 SqlSession session = factory.openSession(); // 使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); // 使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users)&#123; System.out.println(user); &#125; // 释放资源 session.close(); in.close(); &#125;&#125; 2.4 使用注解在 dao 接口的查找方法上添加@Select注解，删除映射配置文件，并在主配置文件中改mapper为： 1&lt;mapper class=\"cn.Retur0.dao.IUserDao\"/&gt; 3 使用 MyBatis 的步骤解析读取配置文件1InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); 此时传入的是路径。由于开发和部署环境的路径会变化，这里路径不写相对路径和绝对路径。常用的方法是： 类加载器。它只能读取类路径配置文件。 使用 ServletContext 对象的 getRealPath() 方法。 创建SqlSessionFactory工厂12SqlSessionFactoryBuilder bulider &#x3D; new SqlSessionFactoryBuilder(); &#x2F;&#x2F; 构建者SqlSessionFactory factory &#x3D; bulider.build(in); 创建工厂 mybatis 使用了构建者模式。构建者是对创建工厂类细节的封装，只需要给 builder 创建工厂类需要的信息（在 SqlMapConfig.xml 中），builder就可以给出工厂类对象。 使用工厂创建SqlSession对象1SqlSession session &#x3D; factory.openSession(); 这里使用了工厂模式。使用工厂模式的优势：解耦，降低类之间的依赖。 使用SqlSession创建Dao接口的代理对象1userDao &#x3D; session.getMapper(IUserDao.class); 创建 Dao 实现类使用了代理模式，可以在不修改源码的基础上对方法增强。 使用代理对象执行方法1234List&lt;User&gt; users &#x3D; userDao.findAll();for(User user : users)&#123; System.out.println(user);&#125; 释放资源12session.close();in.close(); 执行 findAll() 的分析整个查询过程，我们需要的提供的信息有： 连接信息。 映射信息： SQL语句 封装结果的实体类全限定类名。 把这连个信息组合起来定义成一个对象，就是Mapper。 创建代理对象的分析Spring中的Proxy。 4 Mybatis 中的 CRUD 操作IUserDao.java 1234567891011121314151617181920212223242526package cn.Retur0.dao;import cn.Retur0.domain.User;import java.util.List;public interface IUserDao &#123; // 查询所有用户 List&lt;User&gt; findAll(); // 保存用户 void saveUser(User user); // 更新用户 void updateUser(User user); // 删除用户 void deleteUser(int id); // 根据id查询用户 User findById(int id); // 根据名称模糊查询用户 List&lt;User&gt; findByName(String username); // 查询总记录条数 int findTotal();&#125; IUserDao.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.Retur0.dao.IUserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"cn.Retur0.domain.User\"&gt; select * from user &lt;/select&gt; &lt;!--配置保存用户--&gt; &lt;insert id=\"saveUser\" parameterType=\"cn.Retur0.domain.User\"&gt; &lt;!--这行语句可以让user插入后的id存到user对象中，不存的话user对象的id是0--&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username, address, sex, birthday) values(#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;); &lt;/insert&gt; &lt;!--配置更新用户--&gt; &lt;update id=\"updateUser\" parameterType=\"cn.Retur0.domain.User\"&gt; update user set username=#&#123;username&#125;, address=#&#123;address&#125;, sex=#&#123;sex&#125;, birthday=#&#123;birthday&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;!--配置删除用户--&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from user where id=#&#123;uid&#125;; &lt;/delete&gt; &lt;!--根据id查询用户--&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"cn.Retur0.domain.User\"&gt; select * from user where id=#&#123;uid&#125;; &lt;/select&gt; &lt;!--根据名称模糊查询用户--&gt; &lt;select id=\"findByName\" parameterType=\"String\" resultType=\"cn.Retur0.domain.User\"&gt; select * from user where username like #&#123;name&#125; &lt;/select&gt; &lt;!--查询总记录条数--&gt; &lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from user &lt;/select&gt;&lt;/mapper&gt; test.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package cn.Retur0;import cn.Retur0.dao.IUserDao;import cn.Retur0.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;public class test &#123; private InputStream in; private SqlSession session; private IUserDao userDao; public void init() throws Exception&#123; // 读取配置文件 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建SqlSessionFactory工厂 SqlSessionFactoryBuilder bulider = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = bulider.build(in); // 使用工厂创建SqlSession对象 session = factory.openSession(); // 使用SqlSession创建Dao接口的代理对象 userDao = session.getMapper(IUserDao.class); &#125; public void destory() throws Exception&#123; // 提交事务 session.commit(); // 关闭资源 in.close(); session.close(); &#125; @Test public void t_findAll() throws Exception&#123; init(); // 使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users)&#123; System.out.println(user); &#125; // 释放资源 destory(); &#125; @Test public void t_saveUser() throws Exception&#123; User user = new User(); user.setUsername(\"saveuser\"); user.setAddress((\"1-1-1\")); user.setSex(\"男\"); user.setBirthday(new Date()); init(); // 使用代理对象执行方法 userDao.saveUser(user); System.out.println(user.getId()); // 释放资源 destory(); &#125; @Test public void t_updateUser() throws Exception&#123; User user = new User(); user.setId(4); user.setUsername(\"updateuser\"); user.setAddress((\"2-1-1\")); user.setSex(\"女\"); user.setBirthday(new Date()); init(); // 使用代理对象执行方法 userDao.updateUser(user); // 释放资源 destory(); &#125; @Test public void t_deleteUser() throws Exception&#123; init(); // 使用代理对象执行方法 userDao.deleteUser(6); // 释放资源 destory(); &#125; @Test public void t_findById() throws Exception&#123; init(); // 使用代理对象执行方法 User u = userDao.findById(1); System.out.println(u.getUsername()); // 释放资源 destory(); &#125; @Test public void t_findByName() throws Exception&#123; init(); // 使用代理对象执行方法 List&lt;User&gt; users = userDao.findByName(\"name%\"); for(User user : users)&#123; System.out.println(user.getUsername()); &#125; // 释放资源 destory(); &#125; @Test public void t_findTotal() throws Exception&#123; init(); // 使用代理对象执行方法 int tol = userDao.findTotal(); System.out.println(tol); // 释放资源 destory(); &#125;&#125; 4.1 parameterType 传递简单类型。 传递 pojo 对象。 MyBatis 使用 ognl 表达式解析对象字段的值，#{} 或者 ${} 括号中的只为 pojo 的属性名称。 传递pojo 包装对象。 开发中通过 pojo 传递查询条件，查询条件是综合的查询条件，不仅包括用户查询条件还包括其他的查询条件（比如将用户购买商品信息也作为查询条件），这是也可以使用包装对象传递输入参数。pojo 类中包含 pojo。 4.2 resultMap当数据库中字段和 pojo 中属性名不相同时，我们需要在映射文件 IUserDao.xml 中添加resultMap 标签。 123456789&lt;resultMap id=\"userMap\" type=\"cn.Retur0.domain.User\"&gt; &lt;!--主键对应的字段--&gt; &lt;id property=\"userId\" column=\"id\"&gt;&lt;/id&gt; &lt;!--非主键对应的字段--&gt; &lt;result property=\"userName\" cloumn=\"username\"&gt;&lt;/result&gt; &lt;result property=\"userAddress\" cloumn=\"address\"&gt;&lt;/result&gt; &lt;result property=\"userSex\" cloumn=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"userBirthday\" cloumn=\"birthday\"&gt;&lt;/result&gt;&lt;/resultMap&gt; 这个标签中的信息是属性名与列名的对应关系。 之后再配置 SQL 语句，标签中就不写 resultType 属性了，写 resultMap 属性，值为上面配置的 resultMap 标签的 id 属性值。这样，Mybatis 便知道实体类的属性名该如何与数据库中的类名对应。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MyaBtis","slug":"MyaBtis","permalink":"http://yoursite.com/tags/MyaBtis/"}]},{"title":"2020.3 | bug汇总#0","slug":"bug汇总0","date":"2020-04-02T01:09:09.000Z","updated":"2020-04-14T05:53:08.412Z","comments":true,"path":"2020/04/02/bug汇总0/","link":"","permalink":"http://yoursite.com/2020/04/02/bug%E6%B1%87%E6%80%BB0/","excerpt":"【日期】：2020/3/29 【问题】：pycharm无法import使用cmd下载的库 【如何修复】：打开 File -&gt;Settings -&gt;Project Interpreter -&gt;点击齿轮按钮 -&gt;add -&gt; 在new enviroment的location中选择一个空文件夹，选中inherit global site-packages，OK。","text":"【日期】：2020/3/29 【问题】：pycharm无法import使用cmd下载的库 【如何修复】：打开 File -&gt;Settings -&gt;Project Interpreter -&gt;点击齿轮按钮 -&gt;add -&gt; 在new enviroment的location中选择一个空文件夹，选中inherit global site-packages，OK。 【日期】：2020/3/30 【问题】：python爬取页面信息时，使用正则，无法找到&lt;br&gt;标签。 【原因】：在浏览器的分析工具中，显示的标签是&lt;br&gt;。但是在爬取的html文件中，标签是&lt;br/&gt;。 【如何发现】：使用findCategory = re.compile(r&#39;&lt;p&gt;.*?&lt;br&gt;&#39;) category = re.findall(findCategory, item)[0]时，出现下标越界异常。print(acategory)发现结果是[]，没有符合正则的字符串。 【如何修复】：将&lt;br&gt;替换为&lt;br/&gt;。 【总结】：在对想要提取的内容写正则时，应当根据爬取的html写，而不是浏览器f12中的内容。 【日期】：2020/4/1 【问题】：Flask在接受post请求时，出现错误404。 【原因】：在地址栏输入地址时没有在末尾加“/”，一按回车自动在末尾添加添加“/”。而在接受表单的route方法中没有在末尾加“/”，导致访问的路径和可以接收的路径只差最后一个“/”。 【如何发现】：在提交表单时，观察路径，发现提交后路径多了一个“/”。 【如何修复】：@app.route(&#39;/test/result/&#39;, methods=[&quot;POST&quot;, &quot;GET&quot;]) 在接收路径最后加”/“。 【总结】：最好在所有路径结尾都加”/“。表单提交时和接收方法的路径不能相差一个“/”","categories":[{"name":"bug汇总","slug":"bug汇总","permalink":"http://yoursite.com/categories/bug%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"汇总","slug":"汇总","permalink":"http://yoursite.com/tags/%E6%B1%87%E6%80%BB/"}]},{"title":"Python爬虫初见","slug":"Python爬虫初见","date":"2020-04-01T10:23:26.000Z","updated":"2020-04-02T02:50:44.246Z","comments":true,"path":"2020/04/01/Python爬虫初见/","link":"","permalink":"http://yoursite.com/2020/04/01/Python%E7%88%AC%E8%99%AB%E5%88%9D%E8%A7%81/","excerpt":"这篇博文让我不小心删掉了。在此留个坑日后来补。 附个简单的爬虫源码：","text":"这篇博文让我不小心删掉了。在此留个坑日后来补。 附个简单的爬虫源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import re # 正则表达式import urllib.error # 获取网页import urllib.requestimport xlwt # 写入excelfrom bs4 import BeautifulSoup # 网页解析findTitle = re.compile(r'&lt;strong&gt;.*?&lt;/strong&gt;') # 创建找到名字的正则表达式findCategory = re.compile(r'&lt;p&gt;.*?&lt;br/&gt;')# 爬取网页def getData(baseurl): datalist = [] html = askURL(baseurl) # 逐一解析数据 bs = BeautifulSoup(html, \"html.parser\") # 经过分析，&lt;div class=\"a0\"&gt;中有我们需要的电影信息。找到页面中所有&lt;div class=\"a0\"&gt;的标签 for item in bs.find_all('div', class_=\"a0\"): data = [] # 保存一部电影的所有信息 item = str(item) # 跳过第一个符合&lt;div class=\"a0\"&gt;的标签 if item == '&lt;div class=\"a0\"&gt;收藏数最多的剧&lt;/div&gt;': continue # 找到需要的内容并提取 title = re.findall(findTitle, item)[0] title = re.sub(\"&lt;/*strong&gt;\", \"\", title) category = re.findall(findCategory, item)[0].replace(\"&lt;p&gt;\", \"\") category = category.replace('&lt;br/&gt;', '') # 存入电影信息中 data.append(title) data.append(category) # 电影信息存入电影列表中 datalist.append(data) return datalist# 得到指定一个URL的网页内容def askURL(url): head = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36 Edg/80.0.361.69\" &#125; request = urllib.request.Request(url, headers=head) html = \"\" try: response = urllib.request.urlopen(request) html = response.read().decode() except urllib.error.URLError as e: if hasattr(e, \"code\"): print(e.code) if hasattr(e, \"reason\"): print(e.reason) return html# 保存数据def saveData(savepath, datalist): workbook = xlwt.Workbook(encoding=\"utf-8\") worksheet = workbook.add_sheet('sheet1') row = 0 for item in datalist: worksheet.write(row, 0, item[0]) worksheet.write(row, 1, item[1]) row = row + 1 workbook.save(savepath)if __name__ == \"__main__\": baseurl = \"http://www.rrys2019.com/html/top/total_fav_list.html\" savepath = r\"C:\\Users\\38487\\Desktop\\Top50.xls\" # 爬取网页 datalist = getData(baseurl) # 保存数据 saveData(savepath, datalist)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"jdbcTemplate","slug":"jdbcTemplate","date":"2020-03-01T03:41:49.000Z","updated":"2020-03-01T03:43:10.338Z","comments":true,"path":"2020/03/01/jdbcTemplate/","link":"","permalink":"http://yoursite.com/2020/03/01/jdbcTemplate/","excerpt":"dbcp在连接数超过最大值时，所有链接都会断开。没有自动回收空闲的功能。 c3p0在连接超过最大空闲连接时间时，会断掉当前连接。有自动回收空闲的功能。 jdbcTemplate是Spring提供的操作数据库的功能。","text":"dbcp在连接数超过最大值时，所有链接都会断开。没有自动回收空闲的功能。 c3p0在连接超过最大空闲连接时间时，会断掉当前连接。有自动回收空闲的功能。 jdbcTemplate是Spring提供的操作数据库的功能。 环境搭建创建数据库和表12345678910create databese spring;use spring;create table t_user( id int primary key auto_increment, username varchar(50), password varchar(32));insert into t_user(username,password)values('jack','123');insert into t_user(username,password)values('rose','456'); 创建bean，数据模型123456public class User&#123; private Integer id; private String username; private String password; //以及属性的setter和getter&#125; API的使用123456789101112131415public class Demo&#123; @Test public void test()&#123; //连接数据库 BasicDataSopurce ds = new BasicDataSource(); ds.setDicerClassName(\"com.nysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql:///spring\"); ds.setUsername(\"root\"); ds.setPassword(\"123456\"); //创建模板 JdbcTemplate jt = new JdbcTempalte(dataSource); jt.update(\"insertr into t_user(username,password) value(?,?);\",\"name03\",\"777\"); &#125;&#125; XML配置通过上面api使用中可以发现，用到的类有BasicDataSopurce，JdbcTemplate。以及实际在项目中，我们应该通过Dao类调用数据库。这些类都可以通过Spring创建。 12345678910111213141516&lt;!--配置DBCP的datasource对象--&gt;&lt;bean id=\"dataSource\" class=\"com.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"dicerClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/bean&gt; &lt;!--配置jdbctemplate对象--&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.jdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置dao--&gt;&lt;bean id=\"userDao\" class=\"com.Retur0.dao.UserDaoImpl\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/&gt;&lt;/bean&gt; 上面是使用DBCP的数据源，下面使用c3p0的数据源，区别在于数据库连接的参数的属性名不一样。 12345678910111213141516&lt;!--配置c3p0的datasource对象--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"dicerClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///spring\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/bean&gt; &lt;!--配置jdbctemplate对象--&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.jdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置dao--&gt;&lt;bean id=\"userDao\" class=\"com.Retur0.dao.UserDaoImpl\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/&gt;&lt;/bean&gt; JdbcDaoSupportJdbcDaoSupport类中含有jdbcTemplate和datasource，可以简化上面的过程。 dao成继承JdbcDaoSupport： 1234567public class UserDaoImpl extends JdbcDaoSupport implements IUserDao&#123; @Override public void add(User user)&#123; //调用父类的getJdbcTemplate方法 getJdbcTemplate().update(\"insertr into t_user(username,password) value(?,?);\",\"name03\",\"777\"); &#125;&#125; 在xml中的配置就简化了： 123456789101112&lt;!--配置c3p0的datasource对象--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"dicerClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///spring\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/bean&gt; &lt;!--配置dao--&gt;&lt;bean id=\"userDao\" class=\"com.Retur0.dao.UserDaoImpl\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 抽取数据库信息在src目录下写db.properties1234driverClass&#x3D;com.mysql.jdbc.DriverjdbcUrl&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;springuser&#x3D;rootpassword&#x3D;123456 beans.xml12345678&lt;context:proterty-placeholder location=\"classpath:db.properties\"/&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"dicerClass\" value=\"$&#123;driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbcUrl&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt;&lt;/bean&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Spring AOP","slug":"AOP","date":"2020-02-29T01:54:14.000Z","updated":"2020-02-29T02:03:42.053Z","comments":true,"path":"2020/02/29/AOP/","link":"","permalink":"http://yoursite.com/2020/02/29/AOP/","excerpt":"1 AOP概述1.1 面向切面编程 Aspact Oriented Programming，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续，Spring框架中的一个重要内容，是函数式编程的一种衍生规范。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率。 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码。 AOP的应用：事务管理，性能监视，安全检查，缓存，日志。 Spring AOP使用纯Java的AOP框架，不需要专门的编译过程的类加载器，在运行期通过代理方式向目标类织入增强代码。 AspectJ是一个基于Java语言的AOP框架，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供代码的织入。","text":"1 AOP概述1.1 面向切面编程 Aspact Oriented Programming，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续，Spring框架中的一个重要内容，是函数式编程的一种衍生规范。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率。 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码。 AOP的应用：事务管理，性能监视，安全检查，缓存，日志。 Spring AOP使用纯Java的AOP框架，不需要专门的编译过程的类加载器，在运行期通过代理方式向目标类织入增强代码。 AspectJ是一个基于Java语言的AOP框架，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供代码的织入。 1.2 AOP实现原理AOP底层采用代理机制进行实现。接口与实现类采用动态代理Proxy，有或没有接口的类都采用cglib字节码增强。 1.3 AOP术语 target：目标类，需要被代理的类。 Joinpoint 连接点：指可能被拦截到的方法。 PointCut 切入点：已经被增强的连接点。 advice 通知/增强：增强代码。 Weaving 织入：指把增强advice应用到目标对象target来创建代理对象proxy的过程。 proxy：代理类。 Aspect：切入点pointcut和通知advice的结合。 1.4 手动代理1.4.1 JDK动态代理目标类的接口： 12345public interface IUserService&#123; public void addUser(); public void updateUser(); public void deleteUser();&#125; 目标类： 12345678910111213141516public class UserServiceImpl implements IUserService&#123; @Override public void addUser()&#123; System.out.println(\"添加用户\"); &#125; @Override public void updateUser()&#123; System.out.println(\"更新用户\"); &#125; @Override public void deleteUser()&#123; System.out.println(\"删除用户\"); &#125;&#125; 切面类：增强代码与切入点的结合 123456789public calss MyAspect&#123; public void before()&#123; System.out.println(\"开启事务\"); &#125; public void after()&#123; System.out.println(\"提交事务\"); &#125;&#125; 工厂类： 12345678910111213141516171819202122232425262728293031323334public class UserServiceFactory&#123; public static IUserService createUserService()&#123; //创建目标对象target IUserService userService = new UserviceImpl(); //声明切面类对象 MyAspect aspect = new MyAspect(); //把切面类的两个方法应用到目标类 //创建JDK代理，拦截方法 IUserService serviceProxy = (IUserservice) Proxy.newProxyInstance( UserServiceFactory.class.getclass(), userService.getClass.getInterfaces(), new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throeable&#123; //开启事务 aspect.before(); //方法返回值是业务方法的返回值 Object retObj = method.invoke(UserService.args); System.out.println(\"拦截返回值\" + retObj); //提交事务 aspect.after(); return retObj; &#125; &#125; ); return serviceProxy; &#125;&#125; 现在，在测试类中调用由工厂类创建的userService对象，实际上是由JDK创建的目标类的代理。在调用userService的方法的前后，都会执行在切面类中定义的增强方法。 测试类： 12345678public class test&#123; @Test public void test1() throws Exception&#123; IUserService userService = UserServiceFactory.createUserService(); userService.deleteUser(); &#125;&#125; 1.4.2 cglib字节码增强 没有接口，只有实现类。 采用字节码增强框架cglib。在运行时，创建目标类的子类，从未对目标类进行增强。 所用jar包：spring-core 工厂类： 1234567891011121314151617181920212223242526272829303132333435public class UserServiceFactory&#123; public static UserServiceImpleateUserService()&#123; //创建目标对象target IUserService userService = new UserviceImpl(); //声明切面类对象 MyAspect aspect = new MyAspect(); //创建增强对象 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(UserServiceImpl.getClass()); //设置回调（拦截） enhancer.Callback(new MethodInterceptor()&#123; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodproxy)&#123; aspect.before(); //放行方法 //Object ret Obj = method.invoke(UserServiceImpl, args); //第二种写法，解耦 Object ret Obj = methodProxy.invokeSuper(proxy,args); aspect.after(); &#125; &#125;); //创建代理对象 UserServiceImpl serviceProxy = (UserServiceImpl) enhancer.create(); return serviceProxy; &#125;&#125; 测试类： 12345678public class test&#123; @Test public void test1() throws Exception&#123; UserServiceImpl userService = UserServiceFactory.createUserService(); userService.deleteUser(); &#125;&#125; 1.5 AOP联盟通知类型AOP联盟为通知Advice定义了org.aopalliance.Advice Spring按照通知Advice在目标类方法的连接点位置，可以分为5类： 前置通知 org.springframework.aop.MethodBeforeAdvice，在目标方法执行前实施增强。 后置通知 org.springframework.aop.AfterRetunringAdvice，在目标方法执行后实施增强。 环绕通知 org.aopalliance.intercept.MethodInterceptor，在目标方法前后实施增强。 异常抛出通知 org.springframework.aop.ThrowAdvice，在方法抛出异常后实施增强。 引介通知 org.springframework.aop.Introductionterceptor，在目标类中添加一些新的方法和属性。 1.6 Spring编写代理导入com.springsource.org.aopalliance-1.0.0.jar（AOP联盟制定的接口）和 spring-aop-5.2.3.RELEASE.jar（Spring对接口的实现）两个jar包。 目标类和手动代理时一样。 切面类： 123456789101112import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;public class MyAspect implements MethodInterceptor&#123; @Override public Object invole(MethodInvocation mi) throws Throwable&#123; System.out.println(\"前\"); Object retobj = mi.proceed(); System.out.println(\"后\"); return retobj; &#125;&#125; beans.xml： 12345678910111213141516171819202122&lt;!--目标类--&gt;&lt;bean id=\"UserService\" class=\"com.Retur0.service.UserServiceImpl\"/&gt;&lt;!--切面类--&gt;&lt;bean id=\"myAspect\" class=\"com.Retur0.service.MyAspect\"/&gt;&lt;!-- 使用工厂bean创建代理时： interfaces：确定接口，多个接口使用array，单个使用value。 target：确定目标。 interceptorNames：通知，切面类，是一个数组。 默认使用jdk代理 如果目标类有接口，采用jdk动态代理。 如果没有接口，采用cglib字节码代理。 如果声明optimize = true，无论是否有接口，都采用cglib。 --&gt;&lt;bean id=\"proxyService\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt; &lt;property name=\"interfaces\" value=\"com.Retur0.service.IUserService\"/&gt; &lt;property name=\"target\" ref=\"UserService\"/&gt; &lt;property name=\"interceptorNames\" value=\"myAspect\"/&gt; &lt;!--使用cglib创建代理--&gt; &lt;property name=\"optimize\" value=\"true\"/&gt;&lt;/bean&gt; test.java： 123456789public class test&#123; @Test public void test()&#123; //获取Spring容器中代理对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans3.xml\"); IUserService userService = (IUserService) context.getBean(\"serviceProxy\"); userService.deleteUser(); &#125;&#125; 1.7 Spring全自动代理beans.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--目标类--&gt; &lt;bean id=\"userService\" class=\"com.Retur0.service.UserServiceImpl\"/&gt; &lt;!--切面类--&gt; &lt;bean id=\"myAspect\" class=\"com.Retur0.aspect.MyAspect\"/&gt; &lt;!-- 全自动配置AOP --&gt; &lt;aop:config proxy-target-class=\"true\"&gt; &lt;!--切入点 被代理的方法 expression：表达式，给每个service的每个方法都被代理 --&gt; &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.Retur0.service.*.*(..))\"/&gt; &lt;!-- 通知 增强代码 --&gt; &lt;aop:advisor advice-ref=\"myAspect\" pointcut-ref=\"myPointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; test.java 123456789public class test &#123; @Test public void test()&#123; //获取Spring容器中代理对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans4.xml\"); IUserService userService = (IUserService) context.getBean(\"userService\"); userService.deleteUser(); &#125;&#125; 2 AspectJ AspectJ是一个基于java 语言的AOP框架。 Spring2.0 之后增加了对AspectJ切点表达式的支持。 @Aspect 是AspectJ1.5的新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面。 2.1 基于XML的AspectJ例子需要的jar包：spring-aspects-5.2.3.RELEASE.jar 目标类使用之前的UserServiceImpl，切面类重写如下：、 AJAspect.java 1234567891011121314public class AJAspect &#123; public void myBefore()&#123; System.out.println(\"advice before the method..\"); &#125; public void myAfter()&#123; System.out.println(\"advice after the method..\"); &#125; public Object myAround(ProceedingJoinPoint jp) throws Throwable&#123; System.out.println(\"advice around the method...before\"); Object obj = jp.proceed(); System.out.println(\"advice around the method...after\"); return obj; &#125;&#125; beans.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--配置UserService--&gt; &lt;bean id=\"userService\" class=\"com.Retur0.service.UserServiceImpl\"/&gt; &lt;!--配置切面对象--&gt; &lt;bean id=\"AJAspect\" class=\"com.Retur0.aspect.AJAspect\"/&gt; &lt;!--配置AOP--&gt; &lt;aop:config &gt; &lt;!--指定切面--&gt; &lt;aop:aspect ref=\"AJAspect\"&gt; &lt;!--指定切入--&gt; &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.Retur0.service.UserServiceImpl.*(..))\"/&gt; &lt;!--配置前置通知--&gt; &lt;aop:before method=\"myBefore\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:before&gt; &lt;!--配置后置通知--&gt; &lt;aop:after method=\"myAfter\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:after&gt; &lt;!--配置环绕通知--&gt; &lt;aop:around method=\"myAround\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.2 基于注解的例子给目标类添加注解@Service。 给切面类添加注解@Component和@Aspect。 1234567891011121314151617181920212223242526@Component@Aspectpublic class AJAspect &#123; //声明一个公共切入点 @Pointcut(\"execution(* com.Retur0.service.UserServiceImpl.*(..))\") public void myPointcut()&#123;&#125; //Before配置了目标方法 @Before(\"myPointcut()\") public void myBefore()&#123; System.out.println(\"advice before the method..\"); &#125; @After(\"myPointcut()\") public void myAfter()&#123; System.out.println(\"advice after the method..\"); &#125; @Around(\"myPointcut()\") public Object myAround(ProceedingJoinPoint jp) throws Throwable&#123; System.out.println(\"advice around the method...before\"); Object obj = jp.proceed(); System.out.println(\"advice around the method...after\"); return obj; &#125;&#125; beans.xml： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--扫描注解--&gt; &lt;context:component-scan base-package=\"com.Retur0\"/&gt; &lt;!--配置注解生效--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--aop配置--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"AJAspect\"&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.3 注解总结@Aspect 声明切片，修饰切面类，从而获得通知。 通知： @Before 前置。 @AfterReturing 后置。 @Around 环绕。 @AfterThrowing 抛出异常。 @After 最终。 切入点： @PointCut，修饰方法private void xxx(){}，之后通过”方法名”过的切入点引用。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Spring","slug":"Spring","date":"2020-02-22T01:59:41.000Z","updated":"2020-05-09T01:36:31.908Z","comments":true,"path":"2020/02/22/Spring/","link":"","permalink":"http://yoursite.com/2020/02/22/Spring/","excerpt":"1 Spring介绍1.1 Spring概述Spring是一个开源框架，与2003年兴起的轻量级Java开发框架。它是为了解决企业应用开发的复杂性而创建的。Spring是一个轻量级的控制反转和面向切面的容器框架。 方便解耦，简化开发： Spring就是专门生产Bean的大工厂，可以将所有对象创建和依赖关系维护由Spring管理。","text":"1 Spring介绍1.1 Spring概述Spring是一个开源框架，与2003年兴起的轻量级Java开发框架。它是为了解决企业应用开发的复杂性而创建的。Spring是一个轻量级的控制反转和面向切面的容器框架。 方便解耦，简化开发： Spring就是专门生产Bean的大工厂，可以将所有对象创建和依赖关系维护由Spring管理。 面向切面（AOP）编程的支持： Spring提供面向切面编程，可以方便实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持：只需要通过配置就可以完成对事物的管理，为无需手动编程。 方便程序的测试： Spring支持Junit4，可以通过注解方便测试Spring程序。 方便集成各种优秀框架： 其内部提供了对各种优秀框架的支持。 降低JavaEE API的使用难度： 对JavaEE开发中一些难用的API（JDBC、JavaMail、远程调用等），都提供了封装，这些API的应用难度大大降低。 1.2 Spring体系结构Spring是一个分层结构，它包含一系列的功能要素并被分为大约20个模块。这些模块如下图所示： 2 Spring快速入门web中集成Spring需要哪些包？IOC是什么？ 2.1 编写流程 下载Spring开发包。 导入Spring的jar包。 配置Spring的核心xml文件 在程序中读取Spring的配置文件来获取bean（new好的对象）。 Spring各个版本的下载地址： https://repo.spring.io/libs-release-local/org/springframework/spring/ 第三方依赖包下载地址： http://s3.amazonaws.com/dist.springframework.org/release/SPR/spring-framework-3.0.2.RELEASE-dependencies.zip 2.2 详细过程写个简单的service。 UserServiceImpl.java 12345678910111213141516public class UserServiceImpl implements UserService&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public void add() &#123; System.out.println(\"创建用户...\" + name); &#125;&#125; 接下来使用Spring IoC控制反转创建实例，在src目录下写beans.xml配置文件。 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置一个bean（对象）--&gt; &lt;bean id=\"userService\" class=\"com.Retur0.service.UserServiceImpl\"&gt; &lt;!--依赖注入数据--&gt; &lt;property name=\"name\" value=\"name01\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; test1.java 1234567891011121314151617public class test1 &#123; @Test public void test()&#123; //1. 加载beans.xml这个Spring配置文件,内部就会创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //2. 从spring容器获取userService对象 UserService us1 = (UserService)context.getBean(\"userService\"); us1.add(); UserService us2 = (UserService)context.getBean(\"userService\"); us2.add(); System.out.println(us1); System.out.println(us2); &#125;&#125; 结果： 1234创建用户...name01创建用户...name01com.Retur0.service.UserServiceImpl@79e2c065com.Retur0.service.UserServiceImpl@79e2c065 会发现其实 us1 和 us2 是同一个对象。 2.3 IoC 控制反转Inverse of Control 控制反转的概念，就是将原本在程序中手动创建对象的控制权，交给Spring框架管理。创建对象的控制权被反转到达了Spring框架。 2.4 DI 依赖注入Dependency Injection 依赖注入，在Spring框架负责创建Bean对象时，动态地将依赖对象注入到Bean组件。 3 创建Spring容器的三种方式3.1 三种方式第一种：ClassPathXmlApplicationContext，参数中传入的是xml文件的对于src的相对路径。 1ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); 第二种：文件系统路径获得配置文件，绝对路径。 1ApplicationContext context = new FilePathXmlApplicationContext(\"C:\\Users\\38487\\Desktop\\IDEAWorkSpace\\SpringDemo\\src\\beans.xml\"); 第三种：使用BeanFactory（已过时）。 12String path = \"C:\\Users\\38487\\Desktop\\IDEAWorkSpace\\SpringDemo\\src\\beans.xml\";BeanFactory factory = new XmlBeanFactory(new FileSystemResource(path)); 在Spring内部： 解析xml文件，获取类名，id，属性。 通过反射，用类型创建对象。 给创建的对象赋值。 3.2 BeanFactory和ApplicationContext的对比 BeanFactory采取延迟加载，第一次getBean时才会初始化Bean。 ApplicationContext是对BeanFactory的扩展，提供了更多功能： 国际化处理。 事件传递。 Bean自动匹配。 各种不同应用程的Context实现。 4 装配Bean4.1 装配Bean的三种方式所谓的装配Bean，就是在xml中写&lt;bean&gt;标签。 第一种：new实现类。 1&lt;bean id=\"userService\" class=\"com.Retur0.service.UserServiceImpl\"&gt;&lt;/bean&gt; 第二种：通过静态工厂方法。 写一个静态工厂类，返回需要的对象。在Bean中配置这个工厂类，使用时getBean(“id”)，返回为需要的对象。 1&lt;bean id=\"userService\" class=\"com.Retur0.service.UserSereviceFactory\" factory-method=\"createUserService\"&gt;&lt;/bean&gt; 第三种：通过实例工厂方法。 写一个工厂类，返回需要的对象。 12&lt;bean id=\"factory\" class=\"com.Retur0.service.UserSereviceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"userService\" factory-bean=\"factory\" factory-method=\"createUserService\"&gt;&lt;/bean&gt; 4.2 Bean的作用域 singleton：单例，在Spring容器中只存在一个Bean实例，默认值。 prototype：每次从容器中调用bean时吗，都返回一个新的实例。每次调用fgetBean()时，相当于执行new XXXBean()。 request：每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境。 session：同一个HTTP Session共享一个Bean，不同session使用不同bean。仅适用于WebApplicationContext环境。 globalSession：一般用于Portlet应用环境，该作用域仅适用于WebApplicationContext环境。 1&lt;bean id=\"userService\" class=\"com.Retur0.service.UserServiceImpl\" scope=\"prototype\"&gt;&lt;/bean&gt; 5 xml依赖注入Bean属性5.1 构造方法注入在bean中，加入给属性初始化的构造函数。这样在xml中可以如下操作： 12345&lt;bean id=\"stu\" class=\"com.Retur0.model.Student\"&gt; &lt;!--相当于调用public Student(String username, String password)构造方法--&gt; &lt;constructor-arg name=\"username\" value=\"name01\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"password\" value=\"123456\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 还可以这么写： 1234&lt;bean id=\"stu\" class=\"com.Retur0.model.Student\"&gt; &lt;constructor-arg index=0 value=\"name01\" type=\"java.lang.String\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=1 value=\"123456\" type=\"java.lang.Integer\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 5.2 属性setter方法注入通过&lt;property&gt;标签注入。 5.3 p命名空间注入在xml文件的约束中加入一行： 1xmlns:p=\"http://www.springframework.org/schema/p\" 这样就引入了p命名空间，这个命名空间中有类的属性。 1&lt;bean id=\"stu\" class=\"com.Retur0.model.Student\" p:username=\"name01\" p:password=\"123456\"&gt;&lt;/bean&gt; 在bean标签中如上配置，便可以使用命名空间对对象的属性进行初始化。 5.4 SpELSpring表达式。 对&lt;property&gt;进行统一编程，所有内容都使用value。 1&lt;property name=\"\" value=\"#&#123;表达式&#125;\"&gt;&lt;/property&gt; #{123}、#{‘name01’}：数字、字符串。 #{beanId}：另一个bean引用。 #{beanId.propName}：操作数据。 #{beanId.toString()}：执行方法。 #{T(类).字段|方法}：静态方法或字段。 5.3 集合注入集合注入的方法是给&lt;property&gt;添加子标签。 数组：&lt;array&gt; List：&lt;list&gt; Map：&lt;map&gt;，map存放k/v键值对，使用&lt;entry key=&quot;&quot; value=&quot;&quot;&gt;描述。 Properties：&lt;props&gt; &lt;prop key=&quot;&quot;&gt;&lt;/prop&gt; 5.4 注解注入注解是一个类，可以在开发中取代xml配置文件。 @Component 取代&lt;bean class=&quot;&quot;&gt;。 @Component 取代&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; @Repository(“名称”) ：dao层。 @Service(“名称”)：service层。 @Controller(“名称”)：web层。 @Autowired：根据类型自动注入。 @Qualifier(“名称”)：指定自动注入的id名称。 @Resource(name=”名称”) @Scope(“prototype”)：bean为多例。 @PostConstruct：自定义初始化。 @PreDestory：自定义销毁。 例： 在本应由xml配置的UserServiceImpl类前加@Component注解以代替在xml中的配置。 test.java 12345678910111213141516@Testpublic void test() throws Exception&#123; /** 使用注解来取代xml中bean的配置。 Spring默认注解不生效，需要在xml中配置context约束以开启注解。 */ //1. 加载beans.xml这个Spring配置文件,内部就会创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //2. 从spring容器获取userService对象 // 如果在@Component中没有配置id，则通过类型获取。 UserService us1 = (UserService) context.getBean(UserServiceImpl.class); us1.add(); System.out.println(us1);&#125; beans.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 配置自动扫描注解的包--&gt; &lt;context:component-scan base-package=\"com.Retur0.service\"/&gt;&lt;/beans&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"Struts2 part1","slug":"Struts2","date":"2020-01-11T04:32:15.000Z","updated":"2020-01-11T05:25:16.810Z","comments":true,"path":"2020/01/11/Struts2/","link":"","permalink":"http://yoursite.com/2020/01/11/Struts2/","excerpt":"框架概述框架就是把一些繁琐的重复性代码封装起来，是程序员再编码中把更多的精力放到业务需求的分析和理解上面。框架封装了很多细节，在使用的时候会非常简单。","text":"框架概述框架就是把一些繁琐的重复性代码封装起来，是程序员再编码中把更多的精力放到业务需求的分析和理解上面。框架封装了很多细节，在使用的时候会非常简单。 SSHstruts spring hibernate SSMspingmvc spring mybatis Struts2的环境搭建Apache发行的MVC框架，是一个表现层框架。 开始 新建项目 将struts2-blank.war中使用到的包都导入。这是官方给的模板。 将struts2-blank.war中class目录下的struts,xml配置文件拷贝到src目录下。 配置struts过滤器。 过滤器的作用是拦截请求，代替servlet，使用Struts的规则去处理请求。 在web.xml中配置Filter 123456789&lt;!-- 配置struts过滤器 拦截所有请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Action的配置 在&lt;struts&gt;中配置package和action、 12345678910111213141516171819&lt;struts&gt; &lt;!-- package:包名，不能有相同的包名，是唯一的 extend:继承，struts-default action:相当于servlet的映射路径(@WebServlet) --&gt; &lt;package name=\"p1\" extends=\"struts-default\"&gt; &lt;!-- name:请求路径名称，没有后缀，和页面上是否写了.action后缀无关 class:处理请求的action类 method:对应执行的方法 result:结果，返回的jsp页面 --&gt; &lt;action name=\"hello\" class=\"cn.Retur0.action.HelloAction\" method=\"sayHello\"&gt; &lt;!-- 成功jsp页面是从WebContent目录下找的 --&gt; &lt;result name=\"success\"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 写HelloAction类和sayHello方法 12345678package cn.Retur0.action;public class HelloAction &#123; public String sayHello() &#123; System.out.println(\"sayHello\"); return \"success\"; &#125;&#125; 在WebContent中添加success.jsp页面 123&lt;body&gt; HelloAction的sayHello方法返回的页面&lt;/body&gt; 整个流程为： 访问/项目名/action名， 这个action在struts.xml中找到对应的方法去访问， 方法返回一个字符串， 根据这个字符串在struts.xml中找到对应要访问的jsp页面。 Struts执行流程 其中黄色部分是我们需要编写的。 Struts配置文件的加载顺序当应用被tomcat加载的时候，struts2的配置文件就已经被加载过了。 加载顺序： default.properties struts-default.xml struts-plugin.xml struts.xml 可修改 struts.properties 可修改 web.xml 可修改 加载顺序的意义在于：对于某些属性的配置，后加载文件中的赋值会覆盖先加载的文件中的值。 举例：修改action访问后缀。 在default.properties中，struts.action.extension这个属性的值决定了在访问action时哪些后缀可以使用户端访问到。它默认为 action,, 意思是后缀为.action或者没有后缀都可以访问 我们可以在struts.xml 中配置一个常量来达到覆盖default.properties中值的效果： 1234&lt;struts&gt; &lt;!-- 配置一个常量 --&gt; &lt;constant name=\"struts.action.extension\" value=\"php\"&gt;&lt;/constant&gt;&lt;/struts&gt; 此时，我们使用.action或者没有后缀访问action就访问不到了，只有使用.php后缀才可以访问到。 也可以在src目录下创建一个struts.properties文件，添加： 1struts.action.extension&#x3D;htm 此时只能通过.htm后缀访问action。struts.properties在struts.xml后加载，struts.action.extension属性被覆盖了。 还可以在web.xml中的filter标签中添加init-param标签： 12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.action.extension&lt;/param-name&gt; &lt;param-value&gt;do&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 此时可以访问到的后缀为.do。 Struts的开发模式可以在struts.xml 中配置一个常量来开启开发模式： 1&lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; 配置开发模式后，错误信息更详细，更改配置文件后不需要重启服务器。 Struts的主要配置元素在&lt;struts&gt;标签里可以写的那些标签 &lt;package&gt;在struts2的配置文件中引入了面对对象的思想，使用了分包管理。易于管理动作类。便于模块化开发动作类。 其中的一些属性： name：包的名称，非空且唯一。 extends： 一般情况下继承struts-default包，但不是必须的。 不继承的话无法使用struts2的核心功能。 struts-default这个包定义在struts-default.xml中。struts-default.xml在struts.xml加载之前加载。 abstract：把包声明为抽象包，抽象包就是用来被继承的。只要是没有&lt;action&gt;元素的包，都可以声明为抽象包。 namespace：命名空间。访问路径=”/命名空间/action名”。 默认值是空字符串。 可用于模块的划分. namespace=&quot;/ns&quot; 查找规则：假设输入路径为”/a/b/c/hello.action”。 先找有没有/a/b/c命名空间，再找有没有/a/b命名空间，最后找有没有/a命名空间，上面三次查找有一次找到了就在其中找hello.action并执行。 &lt;action&gt;配置动作，处理请求路径。 其中的一些属性： name：动作名称。 class：动作全类名。相当于一个Servlet类。 method：动作类中的方法名称。默认是public String execute(){} 方法的要求：是public，返回类型是String，没有参数。（返回值可以写void，代表没有处理后的跳转页面） 动作类的三种写法 直接写action的java类并在struts.xml中配置。 写action类并实现Action接口，然后在类中实现execute()方法。如果在struts.xml中没有指定method，则默认使用execute方法。 写action类并继承ActionSuport类，ActioSuport是Action接口的实现类。 如果在struts.xml中添加action却不写对应的action类，则会默认调用ActionSuport类中的execute()方法。在struts-default.xml中的&lt;default-class-ref class=&quot;&quot;/&gt;标签实现了这一点。 如果想修改默认动作类，可以在package标签中配置&lt;default-class-ref class=&quot;&quot;/&gt;。 一个package中可以配置多个action。 通配符12345&lt;package name=\"p1\" extends=\"struts-default\" namespace=\"/user\"&gt; &lt;action name=\"*_*\" class=\"cn.Retur0.web.action.UserAction\" method=\"&#123;1&#125;\"&gt; &lt;result name=\"success\"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 若在WebContent目录下有一个Student文件夹，其中有add.jsp。在UserAction方法中有一个返回值是”success”的add()方法。那么在访问/项目名/add_student时，就会访问到add.jsp。因为第一个*的内容可以由{1}指代，第二个*的内容可以有{2}指代，所以实际上method=&quot;add&quot;，result标签中的路径是/student/add.jsp。 动态调用访问时：/action名!方法名 在struts.xml中添加常量标签来启用动态调用： 123456&lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"&gt;&lt;/constant&gt;&lt;package name=\"p1\" extends=\"struts-default\"&gt; &lt;action name=\"student\" class=\"cn.Retur0.web.action.UserAction\"&gt; &lt;result name=\"success\"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; &lt;result&gt;为动作指定结果视图。 属性： name：逻辑视图的名称，对应着动作方法的返回值。默认值是success。 type：结果类型，指的是用什么类型转到定义的页面。默认是dispatcher。 dispatcher：默认值，使用请求转发，转向一个页面。 redirect：使用重定向，转向一个页面。 chain：转发到另一个相同命名空间的动作，也可以转发到不同命名空间的动作。 redirectAction：重定向到另一个相同命名空间的动作，也可以重定向到不同命名空间的动作。 type属性的取值在struts-defalut.xml中定义着。 转发或重定向到不同包的action的result写法： 1234&lt;result name=\"success\" type=\"chain\"&gt; &lt;param name=\"namespace\"&gt;/ns&lt;/param&gt; &lt;param name=\"actionName\"&gt;/an&lt;/param&gt;&lt;/result&gt; 这种写法叫依赖注入，它会把参数传入到被使用的类中。 自定义结果类型result的type除了上面的4中，还可以自己定义结果类型。 写自定义结果类型，需要写一个实现result接口的类。com.opensymphony.xwork2.Result 实现result类要有一个doExecute方法，用于执行结果视图。 setp： 写一个类继承StrutsResultSupport或者实现Result接口。 重写doExecute方法。 12345678910111213141516public class CAPTCHAResult extends StrutsResultSupport&#123; private int width; private int height; //public get set wedth height; @Override protected void doExecute(String finalLocation,ActionInvoaction invocation)throws Exception&#123; //创建验证码 ValidateCode vc = new ValidateCode(width,height,4,8); //获取响应头 HttpServletResponce resp = ServletActionContext.getRequest(); //相应给客户端页面 vc.write(resp.getOutputStream()); &#125;&#125; 配置struts.xml 12345678910111213&lt;package name=\"p1\" extends=\"struts-default\" namespace=\"/n1\"&gt; &lt;!-- 声明自定义结果类型 --&gt; &lt;result-types&gt; &lt;result-type name=\"captcha\" class=\"cn.Retur0.web.result.CAPTCHAResult\"&gt;&lt;/result-type&gt; &lt;/result-types&gt; &lt;action name=\"captchaAction\"&gt; &lt;!-- 此时result标签不需要写跳转路径，因为此动作并没有跳转 --&gt; &lt;result name=\"success\" type=\"captcha\"&gt; &lt;param name=\"width\"&gt;120&lt;/param&gt; &lt;param name=\"height\"&gt;30&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 最后，访问/n1/captchaAction即可得到一个验证码。 在result标签中可以使用param标签添加一些参数，param标签的name属性是参数的名字，标签包裹的是参数的值，这样struts自动把参数传入到action类中。 全局视图和局部视图上面的那种自定义返回类型配置就是局部视图，只能在p1下才能使用captcha这个返回类型。如果想在不同包下使用返回类型captcha，则声明一个可以被继承的抽象包，在这个抽象包中声明返回结果类型。 12345678910111213&lt;package name=\"myDefault\" extends=\"struts-default\" abstract=\"true\"&gt; &lt;result-types&gt; &lt;result-type name=\"captcha\" class=\"cn.Retur0.web.result.CAPTCHAResult\"&gt;&lt;/result-type&gt;&lt;/package&gt; &lt;package name=\"p1\" extends=\"myDefault\" namespace=\"/n1\"&gt; &lt;action name=\"captchaAction\"&gt; &lt;result name=\"success\" type=\"captcha\"&gt; &lt;param name=\"width\"&gt;120&lt;/param&gt; &lt;param name=\"height\"&gt;30&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 这样就可以在不同包使用captcha返回类型了 动作类中的servlet api访问在action中获取request，response，session，application对象。 获取servlet的api方式： 通过ServletActionContext获取。 通过注入方式，先让Action实现ServletRequestAware和ServletResponseAware两个接口。（Aware：注入） 注入原理：struts中有个ServletConfigIntercepto拦截器，自动对action进行一些赋值。","categories":[{"name":"Struts2","slug":"Struts2","permalink":"http://yoursite.com/categories/Struts2/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"事务_连接池_JNDI","slug":"事务-连接池-JNDI","date":"2019-12-02T03:24:07.000Z","updated":"2019-12-02T03:25:40.579Z","comments":true,"path":"2019/12/02/事务-连接池-JNDI/","link":"","permalink":"http://yoursite.com/2019/12/02/%E4%BA%8B%E5%8A%A1-%E8%BF%9E%E6%8E%A5%E6%B1%A0-JNDI/","excerpt":"MySQL事务事务是指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。 如果有两条sql语句执行，要么两条sql语句都执行成功，要么两头都不执行。","text":"MySQL事务事务是指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。 如果有两条sql语句执行，要么两条sql语句都执行成功，要么两头都不执行。 例：A给B转账 12update account set money=money-100 where name='a';update account set money=money+100 where name='b'; 数据库开启事务命令 mysql支持事务 mysql默认自动提交事务，每条语句都处在单独的事务中。 事务操作 start transaction 开启事务 Rollback 回滚事务 commit 提交事务 JDBC使用事务当jdbc程序向数据库获得一个Connection对象时，默认情况下这个Connection对象会自动向数据提交在它上面发送的sql语句。若想关闭这个默认提交方式，让多条sql在同一个事物中执行，可以用connection对象中一些方法来实现上面提到的三个事务操作。 Connection.setAutoCommit(false); start transaction Connection.rollback(); rollback Connection.commit(); commit 1234567891011121314151617181920212223242526272829303132333435363738public class Demo01 &#123; public static void main(String[] args)&#123; // 通过java代码进行转账 // 获取连接 Connection conn = null; Statement stmt = null; try &#123; conn = DBUtils.getConnection(); stmt = conn.createStatement(); // 设置事务的隔离级别 conn.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ); // 开启事务 conn.setAutoCommit(false); // 转账a账号转100给b账号 stmt.executeUpdate(\"update account set money=money-100 where name ='a'\"); int i = 1/0; // 制造异常 stmt.executeUpdate(\"update account set money=money+100 where name ='b'\"); // 提交事务 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 如果遇到错误就进行回滚 try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; // 关闭资源 DBUtils.close(conn, null, stmt); &#125; &#125;&#125; 事物的特性原子性：指事物是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性：事务必须使数据库从一个一致性状态变换成另一个一致性状态。转帐前和转账后的总金额不变。 隔离性：事物的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事物，不能被其他食物的操作数据所干扰，多个并发事物之间要相互隔离。 持久性：指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 事物的隔离级别数据库并发操作可能会引起下面的问题： 脏读：指一个事务读取了另外一个事务未提交的数据。 不可重复读：在一个事务内读取表中的某一行数据，多次读取结果不同。一个事务取到了另一个事务提交后的数据。(update) 虚读（幻读）：指在一个事务内读取到了别的事物插入的数据，导致前后读取不一致。(insert) 数据库通过设置事物的隔离级别来防止以上情况的发生： READ UNCOMMITED[读未提交]：上述三种情况都有可能发生。 READ COMMITED[读已提交]：可以避免脏读。（oracle默认） REPEATABLE READ[可重复度]：避免脏读，不可重复度。虚读有可能发生。（MySQL默认） SERIALIZABLE：避免上面三种情况。不能多线程操作。 数据越安全，性能越低。 MySQL中： 查看当前事务隔离级别：SELECT @@TX_ISOLATION; 更改当前的事务隔离级别：SET TRANSACTION ISOLATION LEVEL 上面四个级别之一。 设置隔离级别必须在事务之前。 隔离级别演示通过两个终端访问数据库来模拟多线程。 数据库连接池当连接数据库的连接数很多时，为每一个用户单独创建连接就变得效率低下了。所以我们有了连接池，在连接池中事先放好很多连接，用户请求连接数据库时，从连接池中拿到连接，用完再放回连接池。 解决了建立数据库连接耗费资源和时间很多的问题，提高性能。 常用的数据库连接池DBCP(Database Connection Pool)数据库连接池，是java数据库连接池的一种，由Apache开发，通过数据库连接池，可以让程序自动管理数据库连接的释放和断开。 C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3和JDBC2的规范，目前使用它的开源项目有Hibernate和Spring。 使用DBCP连接数据库导入commons-DBCP和commons-pool两个包。 使用db.properties配置数据库和连接池的设置。 使用C3P0连接数据库添加C3P0.jar包。 编写配置文件c3p0-config.xml，放在classpath或classes目录中。 JNDIJava Naming and Directory interface是一个应用程序设计的API。为开发人员提供查找和访问各种命名和服务的通用、统一的接口。类似于JDBC都是构建在抽象层上。现在JNDI已经成为了J2EE的标准之一，所有的J2EE容器都必须提供一个JNDI服务。 Tomcat中配置JNDI数据源开发JavaWeb应用，必须使用一个JavaWeb服务器，JavaWeb服务器都内置数据源。这种配置就是JNDI。 Tomcat中内置了数据源DBCP，使用数据源只需要配置服务器即可。 配置数据源的步骤 拷贝数据库连接驱动的jar到tomcat的lib目录下。 出现java.lang.AbstractMethodError请使用更高版本的数据库驱动连接。 配置数据源的XML文件 如果把配置信息写在tomcat下conf目录的context.xml中，那么多有应用都能使用此数据源。 如果是配置在应用的META-INF中创建context.xml，编写数据源，那么是由当前应用可以使用。 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Context&gt; &lt;Resource name=\"jdbc/db1\" auth=\"Container\" type=\"javax.sql.DataSource\" username=\"root\" password=\"123456\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql//localhost:3306/db1\" maxTotal=\"8\" maxIdle=\"4\" /&gt;&lt;/Context&gt; 使用连接池 1234567891011121314151617181920212223242526272829303132333435363738394041public class DBUtils &#123; private static DataSource ds; static &#123; try &#123; // 读取数据源context.xml Context context = new InitialContext(); ds = (DataSource)context.lookup(\"java:comp/env/jdbc/dbdemo\"); &#125; catch (NamingException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; public static void close(Connection conn, ResultSet rs, Statement stmt)&#123; if(rs!=null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt!=null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 多个数据源一个项目中可能要访问多个数据库。 声明多个&lt;Resource/&gt;即可。 数据源：可以理解为数据库连接池。有3中实现方式： DBCP。 C3P0，一般与hibernate一起使用。 JNDI，tomcat内置的dbcp。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"JSP基础知识","slug":"JSP基础知识","date":"2019-11-26T10:13:32.000Z","updated":"2019-11-26T10:12:11.038Z","comments":true,"path":"2019/11/26/JSP基础知识/","link":"","permalink":"http://yoursite.com/2019/11/26/JSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"JSP概述 Java Servler Pages，sun公司定义的一种用于开发动态web资源的技术。JSP实际上就是Servlet。 JSP最大的特点在于可以在html中嵌套java代码，为用户提供动态数据。 举例：在jsp页面中输出当前时间。","text":"JSP概述 Java Servler Pages，sun公司定义的一种用于开发动态web资源的技术。JSP实际上就是Servlet。 JSP最大的特点在于可以在html中嵌套java代码，为用户提供动态数据。 举例：在jsp页面中输出当前时间。 1234567891011121314151617&lt;%@page import=\"java.util.Date\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CurrentTime&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //输出当前日期 Date date = new Date(); out.write(date.toString());%&gt;&lt;/body&gt;&lt;/html&gt; 在旧的eclipse中使用jsp，需要导入tomcat中的jsp.jar和servlet-api.jar两个包。 在访问jsp页面时，会先将其编译成jsp.java，再编译成jsp.class。 eclipse创建jsp文件默认编码格式为ISO-8859-1，在Window-&gt;Preferences-&gt;web-&gt;JSP Files中找到Encoding，换成UTF-8，搞定。 JSP之间提交数据的例子：login.jsp 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"handlelogin.jsp\" method=\"post\"&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input id=\"username\" type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;input type=\"submit\" value=\"登陆\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; handlelogin.jsp 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); out.write(username + \" \" + password); %&gt;&lt;/body&gt;&lt;/html&gt; 结果：在第一个页面提交的数据会出现在第二个页面上。 一般由servlet处理提交的数据而不用jsp。 request,response,out都是jsp的内置对象，不需要创建直接可以使用。 JSP的基本使用JSP模板元素网页静态元素：html标签和文本 JSP的脚本小脚本：&lt;% java代码 %&gt; 表达式：&lt;%= 2+3%&gt;等价于out.print(2+3); 声明：&lt;%! %&gt;表示在类中定义全局成员，静态块 JSP注释JSP注释：&lt;%-- --%&gt;安全、省流量。 网页注释：&lt;!-- --&gt;不安全、费流量。 JSP指令JSP指令（directive）是为JSP引擎而设计的，他们并不直接产出任何可见输出，而知识告诉引擎如何处理JSP页面中的其余部分。 在JSP2.0规范中共定义了三个指令：page、include、taglib。 如JSP的默认第一行： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; pageimport：与java的import一样，用于导入包。 errprPage：如果页面中有错误，则跳转到指定的资源。 路径如果不写”/“则是相对路径，写”/“则从WebContent开始的绝对路径。 contextType：告诉浏览器后面内容的格式，等同于response.setContextType(&quot;text/html;charset=utf-8&quot;); pageEncoding：告诉JSP引擎编译这个文件使用的编码。 isELIgnored：是否支持EL表达式，默认false。 include把其他资源包含到当前页面中。 静态包含：在编译时就把两个文件合并。编译完只有一个文件。 &lt;%@ include file=&quot;include/header.jsp&quot;%&gt; 动态包含：不会合并文件，当代码执行到include时，才会包含另一个文件的内容。编译完有两个文件。 &lt;jsp:include page=&quot;/include/header.jsp&quot;&gt;&lt;/jsp:include&gt; 能用静态包含就不要用动态包含。 taglib在JSP页面中导入标签库，代替jsp中的Java代码片段。 JSP的常用动作&lt;jsp:include&gt;：动态包含另一个jsp内容进入当前的jsp页面。 &lt;jsp:forward page=&quot;&quot;&gt;：请求转发。 &lt;jsp:param&gt;：设置请求参数。可以由请求转发标签包裹。 &lt;jsp:useBean id=&quot;book[对象名]&quot; class=&quot;类&quot;&gt;：创建一个对象。 &lt;jsp:setProperty name=&quot;book[对象名]&quot; property=&quot;bookname[成员变量名]&quot; value=&quot;葵花宝典[bookname成员变量的值]&quot;&gt;：给指定的对象属性赋值。 &lt;jsp:getProperty name=&quot;book[对象名]&quot; property=&quot;bookname[成员变量名]&quot;&gt;：取出指定对象的属性值 JSP的内置对象内置对象是不用new可以直接使用的对象。 pageContextpageContext本身是一个域对象，它可以操作其他三个域对象[request,session,application]的数据。 数据的存储方式：存在域对象中 ServletContext[application]：范围最大，在整个应用中是共享的。其中存的值所有servlet都可以拿到。 Session：同一个会话中有效。同一个浏览器同一个session。一次会话。 request：在同一个请求对象中有效。在request中设置的变量通过转发才可以让另外一个servlet取到值。一次请求。 常用方法： void setAttribute(String name,Object o); Object getAttribute(String name); void removeAttribute(String name); 操作其他域对象的方法： void setAttribute(String name, Object o, int Scope); Object getAttribute（String name, int Scope); void removeAttribute(String, int Scope); scope的值： PageContext.PAGE_SCOPE（作用域是当前页面） PageContext.REQUEST_SCOPE PageContext.SESSION_SCOPE PageContext.APPLICATION_SCOPE findAttribute(String name)自动从page request session application中依次查找，找到了就取值，结束查找。 通过pageContext获取其他8个对象pageContext.getPage();等价于直接用page。 pageContext的简易方法pageContext.forward(“2.jsp”); pageContext.include(“2.jsp”); JS的EL表达式Expression language，表达式语言，用于简化jsp中java代码的开发。它不是一种语言，是jsp中获取数据的一种规范。 EL的具体功能获取数据 EL只能获取4个作用域中的数据。 ${x}用于简化pageContext.findAttribute(“x”); 12345678&lt;%User user = new User(\"name01\", \"20\", \"male\");request.setAttribute(\"user\",user);%&gt;$&#123;user.name&#125;&lt;br&gt;$&#123;user.age&#125;&lt;br&gt;$&#123;user.gender&#125;&lt;br&gt; user.name实际上是调用user对象的getUsername方法。 显示结果： name01 20 male EL的使用方法：${作用域key.属性名} EL获取对于向null这样的数据，在页面中表现为空字符串。 集合数据获取：通过下表或key获取。 1234567891011121314151617181920&lt;%List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(\"str1\");list.add(\"str2\");list.add(\"str3\");Map&lt;String,String&gt; company = new HashMap&lt;String,String&gt;();company.put(\"name\",\"东亚重工\");company.put(\"address\",\"asia\");request.setAttribute(\"list\", list);request.setAttribute(\"company\", company);%&gt;$&#123;list[0]&#125;&lt;br&gt;$&#123;list[1]&#125;&lt;br&gt;$&#123;list[2]&#125;&lt;br&gt;$&#123;company['name']&#125;&lt;br&gt;$&#123;company['address']&#125;&lt;br&gt; 显示结果 拿map的属性使用中括号。 属性导航1234567&lt;%User user = new User(\"name01\", \"20\", \"male\");user.setAddress(new Address(\"中国\",\"河北\"));%&gt;$&#123;user.address.country&#125;&lt;br&gt;$&#123;user.address.province&#125;&lt;br&gt; user类中一个address类的成员变量，address中有country和province两个属性。EL可以属性导航取到country或province。 显示结果： 中国 河北 空运算empty用于判断null，空字符串和没有元素的集合（即使集合对象本身不为null）都返回ture。 123456789101112&lt;%List&lt;String&gt; list = new ArrayList&lt;String&gt;();request.setAttribute(\"list\",list);request.setAttribute(\"str1\", \"\");request.setAttribute(\"str2\", null);request.setAttribute(\"str3\", \"name\");%&gt;$&#123;empty list&#125;$&#123;empty str1&#125;$&#123;empty str2&#125;$&#123;empty str3&#125; 显示结果： true false true false 三元运算符1234567&lt;%//1：男，0：女request.setAttribute(\"gender\",1);%&gt;性别：&lt;input type=\"radio\" $&#123;gender == 1 ? \"checked='checked'\" : \"\"&#125;&gt;男&lt;input type=\"radio\" $&#123;gender == 0 ? \"checked='checked'\" : \"\"&#125;&gt;女 EL的隐式对象pageContext 和jsp的pageContext一样 pageScope 页面范围数据 requestScope 请求范围数据 sessionScope 会话范围数据 applicationScope 应用范围数据 param 一个请求参数 paramValues 重名请求参数 header 一个请求消息头 headerValues 重名请求消息头 initParam web.xml中全局参数 cookie key是cookie对象的name值 除了pageContext之外的隐式对象都是map类型的。 EL表达式获取各个域中的数据。 1234567891011&lt;%pageContext.setAttribute(\"p1\",\"page\",PageContext.PAGE_SCOPE);pageContext.setAttribute(\"p2\",\"request\",PageContext.REQUEST_SCOPE);pageContext.setAttribute(\"p3\",\"session\",PageContext.SESSION_SCOPE);pageContext.setAttribute(\"p4\",\"application\",PageContext.APPLICATION_SCOPE);%&gt;//用EL表达式从指定的作用域取值$&#123;pageScope.p1&#125;&lt;br&gt;$&#123;requestScope.p2&#125;&lt;br&gt;$&#123;sessionScope.p1&#125;&lt;br&gt;$&#123;applicationScope.p1&#125;&lt;br&gt; 显示结果： page request session application 获取上下文路径名（项目名）： ${pageContext.request.getContextPath} 可以灵活设置servlet的访问路径。 通过EL表达式获取请求参数： ${param[&#39;username&#39;]} ${param[&#39;password&#39;]} username和password通过参数传进来，这两个表达式返回key对应的value。 通过EL表达式获取请求头数据： ${header[&#39;Accept&#39;]}可以拿到请求头里Accept的value。 通过EL表达式获取cookie数据： ${cookie[&#39;JSESSIONID&#39;]}可以拿到cookie对象。 ${cookie[&#39;JSESSIONID&#39;].value}可以拿到cookie对象中JSESSIONID的value。 JSTLJavaServerPage Standard Tag Library：jsp标准标签库。使用JSTL可以实现jsp页面中的逻辑处理。如判断、循环等。 在导入JSTL的jar包后，在顶部添加jsp指令： &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; 通用标签：set、out、remove123456&lt;!-- 存一个变量值 --&gt;&lt;c:set var=\"num\" value=\"120\" scope=\"page\"&gt;&lt;/c:set&gt;&lt;!-- 取出变量值 --&gt;&lt;c:out value=\"$&#123;num&#125;\" default=\"0\"&gt;&lt;/c:out&gt;&lt;!-- 从作用域中移除变量 --&gt;&lt;c:remove var=\"num\"&gt;&lt;/c:remove&gt; 条件标签：if、choose12345678910111213141516171819&lt;c:set var=\"a\" value=\"3\"&gt;&lt;/c:set&gt;&lt;!-- c:if 判断 --&gt;&lt;!-- test属性中写EL表达式--&gt;&lt;c:if test=\"$&#123;a &lt; 5&#125;\"&gt; a的值小于5&lt;/c:if&gt;&lt;!-- c:choose 选择 --&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;a == 1&#125;\"&gt; a=1 &lt;/c:when&gt; &lt;c:when test=\"$&#123;a == 2&#125;\"&gt; a=2 &lt;/c:when&gt; &lt;c:when test=\"$&#123;a == 3&#125;\"&gt; a=3 &lt;/c:when&gt;&lt;/c:choose&gt; 迭代标签：forEach1234567891011121314151617181920&lt;!-- c:foreach 普通遍历 --&gt;&lt;!-- var 声明变量begin 开始end 结束step 递增数--&gt;&lt;c:forEach var='i' begin='1' end='10' step='3'&gt; $&#123;i&#125;&lt;br&gt;&lt;/c:forEach&gt;&lt;!-- 14710--&gt;&lt;c:forEach items=\"$&#123;list&#125;\" var=\"name\" varStatus=\"vs\"&gt; 循环集合&lt;/c:forEach&gt; 迭代器： c:forEach中的varStatus属性。 指向一个字符串，该字符串引用一个对象。 这个对象记录着当前遍历元素的一些信息： getIndex()：返回索引。从0开始。${vs.index} getCount()：返回计数。从1开始。${vs.count} isLast()：是否是最后一个元素。${vs.last} isFirst()：是否是第一个元素。${vs.first} 例子：一个chart12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@page import=\"java.util.ArrayList\"%&gt;&lt;%@page import=\"java.util.List\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;chart&lt;/title&gt;&lt;style type=\"text/css\"&gt; .odd&#123; background-color:#a6a6a6; &#125; .even&#123; background-color:pink; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;% //集合数据 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"name01\"); list.add(\"name02\"); list.add(\"name03\"); list.add(\"name04\"); list.add(\"name05\"); list.add(\"name06\"); //存数据 request.setAttribute(\"list\", list); %&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;索引&lt;/td&gt; &lt;td&gt;是否第一个&lt;/td&gt; &lt;td&gt;是否最后一个&lt;/td&gt; &lt;td&gt;计数&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"name\" varStatus=\"vs\" &gt; &lt;tr class=\"$&#123;vs.count %2 == 0 ? 'even' : 'odd' &#125;\" &gt; &lt;td&gt;$&#123;name&#125;&lt;/td&gt; &lt;td&gt;$&#123;vs.index&#125;&lt;/td&gt; &lt;td&gt;$&#123;vs.first&#125;&lt;/td&gt; &lt;td&gt;$&#123;vs.last&#125;&lt;/td&gt; &lt;td&gt;$&#123;vs.count&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 效果： jsp在编写时省了不少力气，但它在编译后是不存在jsp语句的。如果在浏览器上查看源代码，会发现被jsp省略的东西（如循环）会一遍一遍的显示在上面。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Session&Cookie","slug":"Session&Cookie","date":"2019-11-25T07:15:03.000Z","updated":"2019-11-25T07:18:42.742Z","comments":true,"path":"2019/11/25/Session&Cookie/","link":"","permalink":"http://yoursite.com/2019/11/25/Session&Cookie/","excerpt":"会话什么是会话会话可以简单理解为：用户打开一个浏览器，点击多个超链接访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。","text":"会话什么是会话会话可以简单理解为：用户打开一个浏览器，点击多个超链接访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 会话过程中要解决的一些问题每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自回产生一些数据，成需要想办法为每个用户保存这些数据。 保存会话的两种技术：CookieCookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 SessionSession是服务器端的技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一的其独享的HttpSession对象。由于Session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的Session中。当用户再去访问服务器中其他的web资源时，其他的web资源再从用户各自的Session中取出数据为用户服务。 Cookie APIjavax.servlet.http.Cookie javax.servlet.http.Cookie类用于创建一个Cookie。 response接口中定义了一个addCookie的方法，它用户在其响应头中增加一个相应的Set-Cookie头字段。 request接口中也定义了一个getCookies方法，它用于获取客户端提交的Cookie。 Cookie应用场景记录上次访问时间12345678910111213141516171819@WebServlet(\"/Servlet01\")public class Servlet01 extends HttpServlet&#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求头的Cookie Cookies[] cks = req.getCookies(); for(Cookies c : cks)&#123; System.out.println(c.getName() + \":\" + c.getValue()); &#125; //创建一个Cookie对象 Cookie ck = new Cookie(\"lastAccessTime\", System.currentTimeMillis()+\"\"); //设置Cookie的存活时间（单位是秒） ck.setMaxAge(60 * 5); //把Cookie返回给客户端（通过响应头传给客户端） resp.addCookie(ck);&#125; Cookie的maxAge方法maxAge()：cookie的缓存时间。默认是-1，默认存在浏览器的缓存中。单位是秒。 负数：表示cookie的数据存在浏览器缓存中。 0：表示删除cookie。 正数：缓存在持久化硬盘上的时间。 Cookie细节 一个cookie只能标识一种信息，它至少含有一个标识该信息的名称（name）和设置值（value)。 一个web站点可以给一个web浏览器发送多个cookie，一个web浏览器也可以存储多个web站点提供的cookie。 浏览器一般只允许存放300个cookie，每个站点最多存放20个cookie，每个cookie的大小限制为4KB。 如果创建了一个cookie，并把它发送到浏览器，默认情况下他是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则须使用maxAge，并给出一个以秒为单位的时间。将最大时效设置为0则是命令浏览器删除该cookie。 案例：记住用户名login.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;login&lt;/title&gt;&lt;script&gt; function getCookieValue(key)&#123; //通过js获取cookie var cookie = document.cookie;//\"remember=true; username=17103202\" //拆分cookie var cks = cookie.split(\"; \"); for(var i=0; i&lt;cks.length; i++)&#123; //取name和value var ckArr = cks[i].split(\"=\"); if(key == ckArr[0])&#123; return ckArr[1]; &#125; &#125; &#125; window.onload = function()&#123; var remember = getCookieValue(\"remember\"); var username = getCookieValue(\"username\"); if(remember == \"true\")&#123; //勾选记住用户名 var rememberTag = document.getElementById(\"remember\"); rememberTag.checked = \"checked\"; //给用户名显示上次登陆的名字 var usernameTag = document.getElementById(\"username\"); usernameTag.value = username; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/RememberLogin/Servlet01\" method=\"post\"&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input id=\"username\" type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;input id=\"remember\" type=\"checkbox\" name=\"remember\" value=\"true\"&gt;记住用户名 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;input type=\"submit\" value=\"登陆\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; RemLogin.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.Retur0.web.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/Servlet01\")public class RemLogin extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setHeader(\"content-type\", \"text/html;charset=utf-8\"); //获取表单请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String remember = req.getParameter(\"remember\"); //简单判断是否登陆成功 boolean success = \"17103202\".equals(username) &amp;&amp; \"111\".equals(password); if(success) &#123; resp.getWriter().write(\"登陆成功\"); &#125;else &#123; resp.getWriter().write(\"登陆失败\"); //清除cookie Cookie[] cks = req.getCookies(); if(cks!=null) &#123; for(Cookie ck : cks) &#123; ck.setMaxAge(0);//删除cookie resp.addCookie(ck); &#125; &#125; &#125; //把remember和username存在cookie中 if(\"true\".equals(remember) &amp;&amp; success) &#123; Cookie ck1 = new Cookie(\"remember\", remember); ck1.setMaxAge(60 * 60); resp.addCookie(ck1); Cookie ck2 = new Cookie(\"username\", username); ck1.setMaxAge(60 * 60); resp.addCookie(ck2); &#125; &#125;&#125; 历史记录查看书的浏览记录客户端：Cookie:historyBookIds=1-3-5 原理在访问过条目1之后将条目1的id存到cookie中反回给客户端，客户端访问条目2的时候将这个cookie发给服务器，并把条目2的id也存进cookie中。如果客户端要显示历史记录，则通过cookie中记载的id信息调出相应的条目信息并显示在浏览器上。在cookie中id通过键值对以字符串的形式进行保存。 Session API 服务器可以为浏览器创建一个session对象，一个浏览器独占一个session。在需要保存用户数据时，可以把用户数据写道浏览器独占的session中。当用户浏览器访问其他程序时，替他程序可以从用户的session中取出用户的数据，为用户服务。 session和cookie的区别在于： cookie是把用户的数据写给用户浏览器。 session是把用户的数据写道用户独占的session中。 session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。 举个例子SessionDemo1: 123456789101112131415@WebServlet(\"/SessionDemo1\")public class SessionDemo1 extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取session对象 HttpSession session = req.getSession(); //存数据到session session.setAttribute(\"name\", \"Retur0\"); //转发到sessiondemo2 resp.sendRedirect(req.getContextPath() + \"/SessionDemo2\"); &#125;&#125; SessionDemo2: 123456789101112131415@WebServlet(\"/SessionDemo2\")public class SessionDemo2 extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取session对象 HttpSession session = req.getSession(); //从session取数据 String name = (String)session.getAttribute(\"name\"); //数据显示在客户端上 resp.getWriter().write(name); &#125;&#125; 结果：在访问SessionDemo1时会跳转到SessionDemo2并显示Retur0。 如果访问SessionDemo1和SessionDemo2的浏览器不同，则无法显示出Retur0。 关闭浏览器再打开，session是不同的。 服务器如何实现一个session服务一个用户浏览器服务器会为每个浏览器分配一个session ID，然后把Session ID通过Cookie的形式存储在客户端。 第一次访问session1时，服务器创建一个session对象，jsessionid在响应头cookie中发送给浏览器并保存。此时如果再次访问session1，jsessionid不会再发给浏览器。 访问seesion2会将jsessionid在请求头中发送给服务器，服务器用这个id找到对应的session读取数据。 Session的应用场景购物车 用户买书-书放在购物车 获取书的id String bookid = req.getParameter(&quot;id&quot;); 通过书的id找到这本书 Book book = DBUtils.findBookById(Integer.parseInt(bookId)); 把这本书放在购物车List&lt;Book&gt; cart 123456List&lt;Book&gt; cart = (List&lt;Book&gt;)req.getSession().getAttribute(\"cart\");//如果第一次没有创建过购物车,不加判断会重复创建新cart，cart中没有以前添加的东西。if(cart == null)&#123; cart = new ArrayList&lt;Book&gt;();&#125;cart.add(book); 把这个cart放入session中 req.getSession().setAttribute(&quot;cart&quot;, cart); 这种方法的问题： 重启浏览器数据会丢失。(解决：把书的id放在cookie中) 重启服务器数据会丢失。(解决：1. 把书的id放在cookie中。2. 把session数据保存起来) 验证码在登陆过程中，生成验证码和验证登录在不同的servlet中，验证码数据在ValidateServet中，LoginServlet中只能获得用户输入的验证码，为了检验这两个码是否相同，需要使用session来共享数据。 将ValidateServlet中的码存入到session中，LoginServlet从session中取出码并和用户输入的码进行比较。 忽略大小写的字符串比较可以使用equalsIgnoreCase()方法。 使用equals方法是一般将字符串放在前面，变量作为参数，这样可以避免空指针异常。 验证结束后需要将验证码服务器中删除。 req.getSession().removeAttribute(&quot;code&quot;); 或者使用invalidate方法，这个方法让session失效，会使session中的所有数据都删除。 HttpSession的常用方法 把数据保存在HttpSession中，该对象也是一个域对象。 void setAttribute(String name, Object value); 存数据。 Object getAttribute(String name); 取数据。 void removeAttribute(String name); 通过key删除数据。 HttpSession.getId() 取session的id。 setMaxInactiveInterval(int interval); 设置session的存活时间。 invalidate; 使此会话无效。 getSession内部执行原理 获取名称为JSESSIONID的Cookie的值。 如果没有这样的cookie，创建一个新的HttpSession对象，分配一个唯一的SessionID，并且向客户端写了一个名字为JSESSIONID = sessionid的cookie。 有这样的cookie，获取cookie中JSESSIONID的值，在服务器内存中根据ID找到那个HttpSession对象。 找到了就取出来使用，找不到从2开始。 使用getSession时可以传进一个布尔值参数，这个参数是true就正常使用。 这个参数是false则根据id查找session对象，找到就返回，找不到返回null，不会创建新的。 Session的状态 创建：当浏览器第一次访问浏览器的动态资源就被创建。 活着：服务器运行时。 死亡： session.invalidate()：强制销毁。 超时：默认30分钟。 setMaxInactiveInterval(int)：设置存活时间，秒。 在web.xml中配置session有效时间。 1234&lt;session-config&gt; &lt;!--30分钟有效时间--&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; Session的持久化确保服务器或单个web应用重启后，能恢复重启前的会话。 把session中存的对象实现Serializable接口。若不实现序列化接口，则在重启服务器的时候会出现session无法序列化的警告。 会话持久化在硬盘中保存的路径是：/work/Catalina/localhost/项目名/SESSION.ser。 持久化状态转化Session在其生命周期中，可能会在运行时状态和持久化状态之间转换。 搁置： 会话从运行时状态转化为持久化状态的过程称为搁置。 以下情况发生时，Session会被搁置： 当服务器重启或单个web应用终止时，web应用中的session会被搁置。 会话处于不活动的时间太长，达到了特定值。 web应用中处于运行状态的会话数目太多部分Session被搁置。 激活： 会话从持久化状态变为运行时状态的过程称为激活。 以下情况发生时，Session会被激活： 当服务器重启或单个web应用重启时，web应用中的Session会被激活。 处于Session中的客户端向web应用发出http请求，相应的Session会被激活。","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"转发与重定向的区别","slug":"转发与重定向的区别","date":"2019-11-23T09:10:52.000Z","updated":"2019-11-25T03:37:15.493Z","comments":true,"path":"2019/11/23/转发与重定向的区别/","link":"","permalink":"http://yoursite.com/2019/11/23/%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"域对象：session,requset,page… 域就是区间、范围。 转发的目的地是在同一项目下。之前在requset中存放的变量不会失效。 重定向可以在不同项目下。在request中存放的变量会失效。","text":"域对象：session,requset,page… 域就是区间、范围。 转发的目的地是在同一项目下。之前在requset中存放的变量不会失效。 重定向可以在不同项目下。在request中存放的变量会失效。 往Servlet01请求域中存一个数据，并转发给Servlet02： 12345678@WebServlet(\"/Servlet01\")public class Servlet01 extends HttpServlet&#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; request.setAttribute(\"name\",\"Jack\"); request.getRequsetDispatcher(\"/Servlet02\"); &#125;&#125; 在Servlet02中把刚刚存在Servlet01的数据显示一下试试： 12345678@WebServlet(\"/Servlet02\")public class OtherServlet extends HttpServlet&#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String name = (String) req.getAttribute(\"name\"); resp.getWriter.write(name); &#125;&#125; 结果会在页面中显示Jack，这就是在转发时request中的存放变量不会失效。转发前后其实是同一个请求。 如果在Servlet01中使用的是重定向： 12345678@WebServlet(\"/Servlet01\")public class Servlet01 extends HttpServlet&#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setAttribute(\"name\",\"Jack\"); resp.sendRedirect(req.getContextPath() + \"/Servlet02\"); &#125;&#125; 则会报空指针异常。因为Write方法不能写空，说明name变量失效了。 转发是requset的方法，重定向是response的方法。在request中定义的变量用response重定向当然会失效。 一个面试题：include(),forward(),sendRedirect()的区别假设Servlet01转发给Servlet02。 sendRedirect()是请求重定向，会向服务器发送两次请求。 forward()是请求转发。 只有Servlet02的数据可以相应给客户端。 include()也是请求转发。 Servlet01和Servlet02的数据都活相应给客户端。 123456789101112@WebServlet(\"/Servlet01\")public class Servlet01 extends HttpServlet&#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取一个请求转发对象 RequsetDispatcher rd = request.getRequsetDispatcher(\"/Servlet02\"); //分别用forward和include执行转发 //rd.forward(req, resp); rd.include(req, resp); &#125;&#125; 转发地址栏不会改变，重定向地址栏会改变。","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Servlet自动跳转","slug":"Servlet自动跳转","date":"2019-10-30T04:09:18.000Z","updated":"2019-10-30T04:10:12.985Z","comments":true,"path":"2019/10/30/Servlet自动跳转/","link":"","permalink":"http://yoursite.com/2019/10/30/Servlet%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC/","excerpt":"","text":"自动刷新1234567891011121314@WebServlet(\"/AutoRefresh\")public class AutoRefresh extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 设置响应内容类型和编码 resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); // 自动刷新 resp.getWriter().write(\"5s后跳转到index.html\"); resp.setHeader(\"Refresh\", \"1\"); resp.setHeader(\"Refresh\", \"5;URL=Index.html\"); &#125;&#125;","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Servlet验证码","slug":"Servlet验证码","date":"2019-10-30T03:20:27.000Z","updated":"2019-10-30T03:28:52.734Z","comments":true,"path":"2019/10/30/Servlet验证码/","link":"","permalink":"http://yoursite.com/2019/10/30/Servlet%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"手写验证码 输出随机图片（CAPTCHA 图像）：Complrtrly Automated Public Turing Test to Tell Computers and Humans Apart（全自动区分计算机和人类的测试）（这个名字绝对是为了缩写拼凑出来的）。 相关主要类 BufferedImage：内存图像 Graphics：画笔 ImageIO：输出图像","text":"手写验证码 输出随机图片（CAPTCHA 图像）：Complrtrly Automated Public Turing Test to Tell Computers and Humans Apart（全自动区分计算机和人类的测试）（这个名字绝对是为了缩写拼凑出来的）。 相关主要类 BufferedImage：内存图像 Graphics：画笔 ImageIO：输出图像 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@WebServlet(\"/VerificationCode\")public class VerificationCode extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; // BufferedImage：内存图像 // Graphics：画笔 // ImageIO：输出图像 // 创建一个图片对象（画布） int width =120; int height =30; BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // 拿到画笔 Graphics graphics = bi.getGraphics(); // 涂背景颜色 graphics.setColor(Color.white); graphics.fillRect(0, 0, width, height); // 画干扰线 // 重新设置画笔颜色 graphics.setColor(Color.red); Random ran = new Random(); Color[] colors = &#123;Color.blue, Color.green, Color.red&#125;; for(int i=0; i&lt;5; i++) &#123; graphics.setColor(colors[ran.nextInt(3)]); int x1 = ran.nextInt(width); int y1 = ran.nextInt(height); int x2 = ran.nextInt(width); int y2 = ran.nextInt(height); graphics.drawLine(x1, y1, x2, y2); &#125; // 画验证码 graphics.setColor(Color.black); int left = 25; for(int i=0; i&lt;4; i++) &#123; int r = ran.nextInt(10); graphics.drawString(r+\"\", left, 20); left+=20; &#125; // 设置响应类型 resp.setContentType(\"image/jpeg\"); // 把图片输出给客户端 ImageIO.write(bi, \"JPEG\", resp.getOutputStream()); &#125; &#125; 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Login&lt;/title&gt;&lt;script type=\"text/javascript\"&gt; function refreshCode()&#123; // 获取img标签 var imgTag = document.getElementById(\"code\"); imgTag.src = '/191023/VerificationCode?' + new Date().getTime(); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"\"&gt; 用户名：&lt;input type=\"text\"&gt;&lt;br&gt; 密码：&lt;input type=\"password\"&gt;&lt;br&gt; 验证码：&lt;input id=\"code\" type=\"text\"&gt;&lt;img src=\"/191023/VerificationCode?\"&gt; &lt;!-- 怎么在a标签中，调用js --&gt; &lt;a href=\"javascript:refreshCode()\"&gt;看不清，换一个&lt;/a&gt; &lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Servlet文件下载","slug":"Servlet文件下载","date":"2019-10-30T03:20:17.000Z","updated":"2019-10-30T03:25:00.049Z","comments":true,"path":"2019/10/30/Servlet文件下载/","link":"","permalink":"http://yoursite.com/2019/10/30/Servlet%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","excerpt":"文件下载将服务器上的文件传输给浏览器。","text":"文件下载将服务器上的文件传输给浏览器。 123456789101112131415161718192021222324252627@WebServlet(\"/Responsedemo4\")public class demo4 extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException&#123; // 处理文件下载（把文件的数据相应给客户端） // 1.文件名 String filename = \"操作系统.md\"; String path = \"C:/Users/Retur0/Desktop/\" + filename; // 文件下载时，如下设置响应类型 // 如果文件名有中文，需要对文本进行URLencode，把中文变成%形式。 // 一个中文对应三个%的数据 filename = URLEncoder.encode(filename, \"utf-8\"); resp.setHeader(\"Content-disposition\", \"attachment;filename=\" + filename); // 2.获取文件输入流 FileInputStream fis = new FileInputStream(path); // 3.获取输出流 ServletOutputStream sos = resp.getOutputStream(); // 4.从文件中读取数据，相应给客户端 byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf)) != -1) &#123; sos.write(buf, 0, len); &#125; // 关闭输入流，输出流会自动关闭 fis.close(); &#125;&#125;","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Servlet的使用","slug":"Servlet的使用","date":"2019-10-27T03:38:35.000Z","updated":"2019-10-27T03:41:40.985Z","comments":true,"path":"2019/10/27/Servlet的使用/","link":"","permalink":"http://yoursite.com/2019/10/27/Servlet%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"概念Server applet：运行在服务器端的小程序。它是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则。我们在自定义类的时候，要实现Servlet接口，复写方法。","text":"概念Server applet：运行在服务器端的小程序。它是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则。我们在自定义类的时候，要实现Servlet接口，复写方法。 快速入门 创建JavaEE项目 定义实现Servlet的类 1public class ServletDemo1 implements Servlet&#123;&#125; 实现接口中的抽象方法 配置Servlet 在web.xml的web-app标签中如下配置： 12345678910&lt;!--配置Servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;// 和&lt;servlet-mapping&gt;中的内容一样 &lt;servlet-class&gt;web.servlet.ServletDemo1&lt;/servlet-class&gt;// servlet应用的全类名&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;// 和&lt;servlet&gt;中的内容一样 &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;// 客户端在访问时使用的url&lt;/servlet-mapping&gt; Servlet执行原理 Servlet作用：处理请求。 当浏览器访问一个路径时，就向tomcat发送一个请求。服务器接收到客户端的请求后，会解析请求URL路径，获取访问的Servlet的资源路径。 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 如果有，则再找到对应的&lt;servlet-class&gt;全类名。 tomcat会将字节码文件加载进内存，并创建其对象。 调用其方法。 Servlet中的生命周期 被创建：执行init方法，只执行一次。 Servlet什么时候被创建？ 默认情况下是第一次被访问时，Servlet被创建。我们可以配置执行Servlet的创建时机。 在web.xml的&lt;servlet&gt;标签下配置。 第一次被访问时创建 &lt;load-on-startup&gt;的值为负数 在服务器启动时创建 &lt;load-on-startup&gt;的值为0或正整数 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。多个用户同时访问时，可能存在线程安全问题。解决方法是尽量不要在Servlet中定于i成员变量。即使定义了成员变量，也不要修改值。 提供服务：执行servlet方法，执行多次。每刷新一次就调用一次。 被销毁：执行destroy方法，执行一次。 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源。 实现servlet的三种方式 实现javax.servlet.Servlet接口。 继承javax.servlet.GenericServlet类（适配器模式）。可以选择性地实现一些方法。 继承javax.servlet.http.HttpServlet类（模板方法设计模式）。比较常用。 Servlet 3.0支持注解配置。可以不用web.xml.了。 步骤： 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml。 定义一个类，实现Servlet接口。 复写方法。 在类上使用@WebServlet注解，如下进行配置： @WebServlet(&quot;/资源路径&quot;) 这个注解中有多个配置，其中value与urlPatterns相关联。只写一个配置时，value可以省略不写。 123456789101112131415@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet&#123; String name default \"\";// 相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;// 代表urlPatterns()属性配置 String[] urlPatterns() defualt -1;// 相当于&lt;url-pattern&gt; int loadOnStarup() default -1;// 相当于&lt;load-on-startup&gt; WebInitParam[] initParams() defalut &#123;&#125;; boolean asyncSupported() default false; String smallIcon default \"\"; String largecon default \"\"; String description() default \"\"; String displayName() default \"\";&#125; IDEA与Tomcat的相关配置 IDEA会为每一个Tomcat部署的项目单独建立一份配置文件。 查看控制台的log：Using CATALINA_BASE: &quot;C:\\Users\\Retur0\\.IntelliJIdea2019.1\\system\\tomcat\\_Tomcat_IDEA&quot; 工作空间项目 和 tomcat的web项目。 tomcat真正访问的是：“tomcat的web项目”。 “tomcat的web项目”对应着“工作空间项目”的web目录下的所有资源。 web-INF目录下的资源不能被浏览器直接访问。 断点调试：使用IDEA中的debug启动 Servlet体系结构Servlet — 接口 |GenericServlet — 抽象类 |HttpServlet — 抽象类 GenericServlet：将Servlet接口中的其他方法做了默认空实现，只将service()方法作为抽象。将来定义Servlet类时，可以继承GenericServlet，实现Service方法即可。 HttpServlet：对http协议的一种封装，简化操作。 定义类来继承HttpServlet 复写doGet/doPost方法 Servlet映射规则urlPatterns： servlet访问路径。一个servlet可以定义多个访问路径。 路径的定义规则：在项目名要写的前提下 *.do：自定义扩展名，通过扩展名找到文件。不加/。任何以“.do”结尾的都可以访问Servlet。do也可以换成其他的。 /*：任何访问都会访问到Servlet。 /action：加/action前缀的都可以访问到Servlet。action可以替换。可以分模块。 ServletContext上下文代表的是整个应用，一个应用只有一个ServletContext对象。是单例对象。 作用域对象。在当前应用，使多个Servlet共享数据。 常用方法void setAttribute(String name, Object value);：向ServeltContext对象的map中添加数据。 Object getAttribute(String name);：从ServletContext对象的map中取数据。 void removeAttribute(String name);：根据name去移除数据。移除后再取数据得到的结果是null。 123456789@WebServlet(\"/Demo1\")public class Demo1 extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp)&#123; // 获取一个应用的Servlet上下文。 ServletContext context = this.getServletContext(); System.out.println(context); // org.apache.catalina.core.ApplicationContextFacade@2f00a69e context.setAttribute(\"name\", \"123\"); &#125;&#125; 1234567891011@WebServlet(\"/Demo2\")public class Demo2 extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp)&#123; // 获取一个应用的Servlet上下文。 ServletContext context = this.getServletContext(); System.out.println(context);// org.apache.catalina.core.ApplicationContextFacade@2f00a69e String str = (String)context.getAttribute(\"name\"); System.out.println(str); context.removeAttribute(\"name\"); &#125;&#125; ServletContext获取全局配置信息xml： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;191023&lt;/display-name&gt; &lt;!-- 上下文参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/context-param&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; servlet： 12345678910@WebServlet(\"/Context2Demo1\")public class Demo1 extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp)&#123; // 通过上下文对象从web.xml中获取全局配置信息 // 在web.xml中context-param配置的信息不是通过getAttribute获得的 // getInitParameter(); String str = (String)this.getServletContext().getInitParameter(\"encoding\"); System.out.println(str); &#125;&#125; 获取资源路径ServletContext的String getRealPath(String path)方法： 根据资源名称得到资源的绝对路径。 可以得到当前应用任何位置的任何资源。 12345678910111213141516@WebServlet(\"/Context3Demo1\")public class Demo1 extends HttpServlet&#123; /** * 通过浏览器地址栏访问的路径都是get请求 */ protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws FileNotFoundException, IOException&#123; // 在Servlet中获得info.properties的数据 // web项目，查找路径，要从类路径找 String path = this.getServletContext().getRealPath(\"WEB-INF/classes/com/Retur0/web/Context3/info.properties\"); // 创建属性对象 Properties pro = new Properties(); // 关联属性文件的路径 pro.load(new FileInputStream(path)); System.out.println(pro.getProperty(\"username\")); &#125;&#125; Servlet的转发12345678910@WebServlet(\"/Demo1\")public class Demo1 extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp)&#123; // response.getWriter().writer(\"data from Servlet1\"); // 获取请求转发的对象 RequestDispatcher rd = request.getRequest(\"/Demo2\"); // 执行转发 rd.forward(req, resp); &#125;&#125; 123456@WebServlet(\"/Demo2\")public class Demo2 extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp)&#123; response.getWriter().writer(\"data from Servlet2\"); &#125;&#125;","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"MySQL下数据备份和恢复","slug":"MySQL下数据备份和恢复","date":"2019-10-21T10:15:26.000Z","updated":"2019-10-21T10:16:31.248Z","comments":true,"path":"2019/10/21/MySQL下数据备份和恢复/","link":"","permalink":"http://yoursite.com/2019/10/21/MySQL%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/","excerpt":"生成SQL脚本 导出数据不需要登陆数据库，在控制台使用mysqldump命令可以生成指定数据库的脚本文本，","text":"生成SQL脚本 导出数据不需要登陆数据库，在控制台使用mysqldump命令可以生成指定数据库的脚本文本，但脚本文本中只包含数据库中的内容，而不会存在创建数据库的语句。所以在恢复数据时，还需要手动创建一个数据库之后再去恢复数据。放在C盘根目录下需使用管理员权限。 mysqldump -u用户名 -p密码 数据库名称&gt;存放目录 执行SQL脚本 恢复数据 登陆数据库。 创建数据库。 执行sql脚本。 SOURCE 脚本目录; mysql -u用户名 -p密码 数据库名称&lt;要执行的脚本的路径; 也可以不登陆mysql： mysql -u用户名 -p密码 数据库名称&lt;要执行的脚本的路径 这个方法也需要先创建数据库。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"XML基础知识","slug":"XML笔记","date":"2019-10-20T11:18:34.000Z","updated":"2019-11-23T09:22:05.934Z","comments":true,"path":"2019/10/20/XML笔记/","link":"","permalink":"http://yoursite.com/2019/10/20/XML%E7%AC%94%E8%AE%B0/","excerpt":"XML概念Extensible Markup Language 可扩展标记语言。可扩展是指标签可以自定义。 功能： 配置文件。 在网络中传输数据。 存储数据。 XML与HTML的区别： w3c：万维网联盟，创建于1994年，是Web技术领域的技术标准机构。 XML的标签都是自定义的，HTML标签是预定义的。 XML依法严格，HTML语法松散。 XML是存储数据的，HTML是展示数据的。","text":"XML概念Extensible Markup Language 可扩展标记语言。可扩展是指标签可以自定义。 功能： 配置文件。 在网络中传输数据。 存储数据。 XML与HTML的区别： w3c：万维网联盟，创建于1994年，是Web技术领域的技术标准机构。 XML的标签都是自定义的，HTML标签是预定义的。 XML依法严格，HTML语法松散。 XML是存储数据的，HTML是展示数据的。 语法基本语法 第一行必须是文档声明。&lt;?xml version=&#39;1.0&#39; ?&gt; 属性 version：版本号，固定为1.0 。 encoding：指定文档的码表。 standalone：文档是否独立，yes或no。如果是yes则表示这个XML文档时独立的，不能引用外部的DTD规范文件。如果是no则可以用外部的DTD文档。（很少用） xml文档有且只有一个根标签。 属性值必须使用引号引起来。 标签必须正确关闭。 xml标签名称区分大小写。数字不能开头。 使用&lt;![CDATA[数据内容]]&gt;以转义。 快速入门123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;students&gt; &lt;student id=\"001\"&gt; &lt;!-- ctrl+shift+/ --&gt; &lt;name&gt;&lt;![CDATA[&lt;name01]]&gt;&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;女&lt;/gender&gt; &lt;birthday&gt;1999-1-1&lt;/birthday&gt; &lt;/student&gt; &lt;student id=\"002\"&gt; &lt;name&gt;name02&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;gender&gt;女&lt;/gender&gt; &lt;birthday&gt;1999-7-1&lt;/birthday&gt; &lt;/student&gt; &lt;student id=\"003\"&gt; &lt;name&gt;name03&lt;/name&gt; &lt;age&gt;30&lt;/age&gt; &lt;gender&gt;女&lt;/gender&gt; &lt;birthday&gt;1999-1-7&lt;/birthday&gt; &lt;/student&gt;&lt;/students&gt; 组成部分 文档声明 格式：&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性。 encoding：编码方式，告知解析引擎当前文档使用的字符集，默认为ISO-8859-1。 standalone：是否独立，取值为yes或no，表示这个文档是否依赖其他文件。 指令：结合CSS的 &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 标签：标签名称自定义的。数字不能开头，名称不能以xml开始，名称不能包含空格，可以包含数字，字母和其他字符。 属性：id属性值唯一。 文本：特殊字符要用转义字符。在CDATA区中的数据会被原样展示。&lt;![CADTA[数据]]&gt; 约束规定xml文档的书写规则。作为框架的使用者，我们应当可以做到在xml中引入约束文档，能够读懂约束文档。 分类 DTD：一种简单的约束技术。 Schema：一种复杂的约束技术。 DTD12345678&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!ELEMENT student (name,password,gender,birthday)&gt;&lt;!ELEMENT students (student*)&gt;&lt;!ELEMENT birthday (#PCDATA)&gt;&lt;!ELEMENT gender (#PCDATA)&gt;&lt;!ELEMENT password (#PCDATA)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 引入dtd文档到xml文档中 内部dtd：将约束文件规则定义在xml文档中。 外部dtd：将约束的规则定义在外部的dtd文件中。 本地：&lt;DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; 网络：&lt;DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE students SYSTEM \"students.dtd\"&gt;&lt;students&gt; &lt;student number=\"S_001\"&gt; &lt;name&gt;name01&lt;/name&gt; &lt;password&gt;123456&lt;/password&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;birthday&gt;1999-1-1&lt;/birthday&gt; &lt;/student&gt;&lt;/students&gt; Schma引入： 填写xml文档的根元素。 引入xsi的前缀，xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间，xsi:chemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 为每一个xsd约束声明一个前缀，作为标识xmlns=&quot;http://www.itcast.cn/xml&quot; 123&lt;students xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.itcast.cn/xml\" xsi:chemaLocation=\"http://www.itcast.cn/xml student.xsd\"&gt; XML解析操作xml文档 解析（读取）：操作xml文档，将文档中的数据存到内存中。 写入：将内存中的数据保存到xml文档中。持久化的存储。 解析xml的方式 DOM：将标记语言文档一次性加载进内存，形成一棵DOM树。 优点：操作方便，可以对文档进行CRUD的所有操作。 缺点：消耗内存。 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改。 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax，慢。 DOM4J：一款优秀的解析器。 Jsoup：是一款Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数值。 PULL：Android内置的解析器，sax方式。 Jsoup是一款Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数值。 快速入门： 步骤： 导入jar包。 获取Document对象。 获取对象的标签。Element对象。 获取数据。 12345678910111213// 根据xml文档获取// 获取student.xml的pathString path = JsoupDemo1.class.getClassLoader().getResource(\"student.xml\").getPath();Document document = Jsoup.parse(new File(path), \"UTF-8\");Elements elements = document.getElementsByTag(\"name\");Element element = elements.get(0);String name = element.text();System.out.println(name); 对象的使用： Jsoup：工具类，可以解析html或xml文档，返回Document。 parse：解析html或xml对象，返回Document。 parse(File in, String charsetName)：解析html或xml的。 paese(String html)：解析html或xml字符串。指的是把文档内容装化成字符串作为参数传进来。 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml文档对象。 ​ Document：文档对象。代表内存中的dom树。继承自Element对象。 获取Element对象 getElementById(Strinf id)：根据id属性值获取唯一元素对象。 getElementsByTag(String TagName)：根据标签名获取元素对象集合。 getElementsByAttribute(String key)：根据属性名获取元素对象集合。 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合。 Elements：元素Element对象的集合。可以当作ArrayList&lt;Element&gt;来使用。 ​ Element：元素对象。 获取子元素对象： getElementById(Strinf id)`：根据id属性值获取唯一元素对象。 getElementsByTag(String TagName)：根据标签名获取元素对象集合。 getElementsByAttribute(String key)：根据属性名获取元素对象集合。 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合。 获取属性值： String attr(String key)：根据属性名称获取属性值。 获取文本内容： String text()：获取所有子标签的纯文本内容。 String html()：获取标签体的所有内容（包括子标签的标签和文本内容）。 ​ Node：节点对象。 快捷查询方式： select：选择器 使用的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法。 select(&quot;student[number=\\&quot;001\\&quot;]&quot; &gt; age) number为shudent的属性，&gt;表示age是student的直接子标签，”a b”表示b是a的子标签或孙标签。 XPath：XML路径语言 ，他是一种用来确定XML文档中某部分位置的语言。 使用Jsoup的Xpath需要额外导入jar包。JsoupXpath-版本号.jar //student：查询所有的student标签。 //student/name：查询所有的student下的name标签。 //student/name[@id]：查询带有id属性的name标签。 //student/name[@id=&#39;001&#39;]：查询id属性为001的name标签。 DOM4J12345678910111213141516171819202122// books.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;书架&gt; &lt;书 number=\"100\"&gt; &lt;书名&gt;Java从入门到入坟&lt;/书名&gt; &lt;作者&gt;谭浩强&lt;/作者&gt; &lt;价格&gt;178&lt;/价格&gt; &lt;出版社&gt;北京大学出版社&lt;/出版社&gt; &lt;/书&gt; &lt;书 number=\"150\"&gt; &lt;书名&gt;Java从入门到入坟&lt;/书名&gt; &lt;作者&gt;谭浩强&lt;/作者&gt; &lt;价格&gt;168&lt;/价格&gt; &lt;出版社&gt;北京大学出版社&lt;/出版社&gt; &lt;/书&gt; &lt;书 number=\"200\"&gt; &lt;书名&gt;Java从入门到入坟&lt;/书名&gt; &lt;作者&gt;谭浩强&lt;/作者&gt; &lt;价格&gt;158&lt;/价格&gt; &lt;出版社&gt;北京大学出版社&lt;/出版社&gt; &lt;/书&gt;&lt;/书架&gt; 12345678910111213141516171819202122232425262728293031public void test1() throws Exception&#123; // 使用dom4j进行xml解析 // 1.创建reader对象 SAXReader reader = new SAXReader(); // 2.读取文档 Document doc = reader.read(new FileInputStream(\"./lib/books.xml\")); // 3.获取跟标签（根节点） Element root = doc.getRootElement(); // 4.获取书架子标签 List books = root.elements(); // 遍历书 for(Object obj : books)&#123; Element book = (Element)obj; // 获取book的属性 System.out.println(book.attributeValue(\"number\")); // 获取标签名 System.out.println(book.getName()); // 获取书名 System.out.println(book.element(\"书名\").getText()); // 获取作者 System.out.println(book.element(\"作者\").getText()); // 获取价格 System.out.println(book.element(\"价格\").getText()); // 获取出版社 System.out.println(book.element(\"出版社\").getText()); System.out.println(\"===========\"); &#125;&#125; 打印结果： 123456789101112131415161718192021100书Java从入门到入坟谭浩强178北京大学出版社&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;150书Java从入门到入坟谭浩强168北京大学出版社&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;200书Java从入门到入坟谭浩强158北京大学出版社&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; XPath专门用于查询，它定义了一种规则。 //nodename 选取此节点 / 从根节点选取 .. 选取此节点的父节点 @ 选取属性 [@属性名] 属性过滤 [标签名] 子元素过滤 1234567891011public void test() throws Exception&#123; // 创建SAXReader SAXReader reader = new SAXReader(); Document doc = reader.read(new FileInputStream(\"./lib/books.xml\")); // 进行XPath查询 List nodes = doc.selectNodes((\"//书名\")); for(Object obj : nodes)&#123; Node node = (Node)obj; System.out.println(node.getText()); &#125; 修改节点保存123456789101112131415161718192021public void test1() throws Exception&#123; // 修改节点保存 // 1.读取节点 SAXReader reader = new SAXReader(); Document doc = reader.read(new FileInputStream(\"./lib/books.xml\")); // 2. 把所有number改成1000 List list = doc.selectNodes(\"//书/@number\"); for(Object obj : list)&#123; if(obj instanceof Attribute)&#123; Attribute att = (Attribute)obj; // 在内存中修改属性值 att.setValue(\"1000\"); &#125; &#125; // 3.保存 XMLWriter writer = new XMLWriter(new FileOutputStream(\"./lib/books.xml\")); writer.write(doc); writer.close();&#125;","categories":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/categories/XML/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"JDBC笔记","slug":"JDBC笔记","date":"2019-10-15T13:05:15.000Z","updated":"2019-10-15T13:06:36.217Z","comments":true,"path":"2019/10/15/JDBC笔记/","link":"","permalink":"http://yoursite.com/2019/10/15/JDBC%E7%AC%94%E8%AE%B0/","excerpt":"JDBC概述Java Database connectivity，Java与数据库连接的操作规范。不同的数据库都要遵循这个规范（接口）。","text":"JDBC概述Java Database connectivity，Java与数据库连接的操作规范。不同的数据库都要遵循这个规范（接口）。 JDBC规范掌握四个核心对象： DriverManager：用于注册驱动。 Connection：表示与数据库创建的连接。 Statement：操作数据库SQL语句的对象。 ResultSet：结果集 或 一张虚拟表。 JDBC的准备工作JDBC接口放在JDK中的 java.sql 和 javax.sql。 下载jdbc的jar包。 导入jar包到项目中。 实现JDBC操作 注册驱动 创建连接 得到执行SQL语句的Statement对象 执行SQL语句，并返回结果 处理结果 关闭资源 DriverManagerjava.sql.DriverManager类：注册驱动，创建连接。 这个类在加载时就会注册驱动，所以在使用时，只需要使用Class.forName(&quot;com.mysql.jdbc.Driver&quot;);来加载一下这个类即可完成注册驱动。使用DriverManager.registerDriver(new Driver());会造成二次注册驱动。 Connection有三种创建连接的方法： Connection conn = DriverManager.getConnection(url,user,password); Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test1?user=root&amp;password=123456&quot;); String url = \"jdbc:mysql://localhost:3306/test1\"; Properties info = new Properties(); info.setProperty(\"user\",\"root\"); info.setProperty(\"password\",\"passwo2d@CQ\"); Connection conn = DriverManager.getConnection(url, info); &lt;!--￼0--&gt; java的数据类型与数据库中类型的对应关系 java 数据库 byte tityint short smallint int int long bigint float float double double String char varchar Date date resultSet用游标记录了当前在哪一行。 next()将游标移动到下一行。previous()将游标移动到上一行。afterLast()将光标移动到末尾，位于最后一行之后。beforeFirst()将光标移动到开头，正好位于第一行之前。 正确关闭资源因为程序中有可能抛出异常，而抛出异常会导致后面的资源无法关闭，所以将close方法放到finally中。再用一套try/catch包裹close来处理close的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static void main(String[] args)&#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; // 1. 注册驱动，使用mysql驱动 // DriverManager.registerDriver(new Driver()); 不建议使用，会导致注册两次驱动。 // Class.forName(\"com.mysql.jdbc.Driver\"); // 2. 创建连接 String url = \"jdbc:mysql://localhost:3306/test1?serverTimezone=GMT\"; Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"passwo2d@CQ\"); conn = DriverManager.getConnection(url, info); // 3. 得到执行SQL语句的Statement对象 stmt = conn.createStatement(); // 4. 执行SQL语句，并返回结果 rs = stmt.executeQuery(\"select * from user;\"); // 5. 处理结果 while (rs.next()) &#123; // 获取5个字段的数据 System.out.print(rs.getObject(1) + \" - \");// id System.out.print(rs.getObject(2) + \" - \");// name System.out.print(rs.getObject(3) + \" - \");// password System.out.print(rs.getObject(4) + \" - \");// email System.out.print(rs.getObject(5) + \" - \");// birthday System.out.println(); &#125; &#125;catch(Exception e)&#123; &#125;finally&#123; // 6. 关闭资源 if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 抽取工具类（简化连接数据库和关闭资源操作）创建一个同级工具类包，内放一个工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.Retur0.util;import java.sql.*;public class DBUtils &#123; private static String url = \"jdbc:mysql://localhost:3306/test1?serverTimezone=GMT\"; private static String user = \"root\"; private static String password = \"passwo2d@CQ\"; //private static String DriverClass = \"com.mysql.jdbc.Driver\";//驱动// static&#123;// try &#123;// Class.forName(DriverClass);// &#125;catch(ClassNotFoundException e)&#123;// e.printStackTrace();// &#125;// &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,user,password); &#125; public static void close(Connection conn, ResultSet rs, Statement stmt)&#123; if(rs!=null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt!=null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 之后连接和操作数据库的代码就简化如下： 1234567891011121314151617181920212223242526272829303132333435package demo;import com.Retur0.util.DBUtils;import java.sql.*;/** * 抽取数据库操作（简化操作）： * 把资源连接封装到一个工具类 * 把关闭资源封装到一个工具类 */public class demo02 &#123; public static void main(String[] args)&#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; conn = DBUtils.getConnection(); stmt = conn.createStatement(); rs = stmt.executeQuery(\"select * from user\"); while (rs.next()) &#123; // 获取5个字段的数据 System.out.print(rs.getObject(1)+\"\\t\");// id System.out.print(rs.getObject(2)+\"\\t\");// name System.out.print(rs.getObject(3)+\"\\t\");// password System.out.print(rs.getObject(4)+\"\\t\");// email System.out.println(rs.getObject(5)+\"\\t\");// birthday &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; DBUtils.close(conn, rs, stmt); &#125; &#125;&#125; 插入数据使用预处理的Statement对象，用占位符代替要处理的数据。使用设置方法挨个设置占位符处的数据。 123456789101112131415161718192021222324252627public static void main(String[] args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = DBUtils.getConnection(); // 创建预处理的Statement对象。?代表占位。 String sql = \"insert into user (id,name,password,email,birthday) values (?,?,?,?,?)\"; ps = conn.prepareStatement(sql); // 设置参数 ps.setInt(1, 4); ps.setString(2, \"name03\"); ps.setString(3, \"123456\"); ps.setString(4, \"11111@qq.com\"); // setDate的日期类型是java.sql.Date,不是java.util.Date ps.setDate(5, new java.sql.Date(System.currentTimeMillis())); int r = ps.executeUpdate(); System.out.println(\"受影响的行数：\"+r); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; DBUtils.close( conn, null, ps); &#125;&#125; 更改数据12345678910111213141516171819202122232425public static void main(String[] args)&#123; // 更改name02的密码和邮箱。 Connection conn = null; PreparedStatement ps = null; try &#123; conn = DBUtils.getConnection(); // 创建预处理的Statement对象。?代表占位。 String sql = \"update user set password=?, email=? where name=?\"; ps = conn.prepareStatement(sql); // 设置参数 ps.setString(1, \"000000\"); ps.setString(2, \"xxx@qq.com\"); ps.setString(3, \"name02\"); int r = ps.executeUpdate(); System.out.println(\"受影响的行数：\"+r); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; DBUtils.close( conn, null, ps); &#125;&#125; 删除数据12345678910111213141516171819202122public static void main(String[] args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = DBUtils.getConnection(); // 创建预处理的Statement对象。?代表占位。 String sql = \"delete from user where id=?\"; ps = conn.prepareStatement(sql); // 设置参数 ps.setInt(1, 4); int r = ps.executeUpdate(); System.out.println(\"受影响的行数：\"+r); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; DBUtils.close( conn, null, ps); &#125;&#125; 查询数据查询不使用预处理Statement。 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args)&#123; // 更改name02的密码和邮箱。 Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; conn = DBUtils.getConnection(); stmt = conn.createStatement(); rs = stmt.executeQuery(\"select * from user\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); // 遍历结果集，把数据封装到模型中 while (rs.next())&#123; // 把每一条数据封装到一个类User类，这个类就是一个数据模型。 // 模型的包名可以是model/domain/po/pojo User user = new User(); user.setId(rs.getInt(\"id\")); user.setName(rs.getString(\"name\")); user.setEmail((rs.getString(\"email\"))); user.setBirthday((rs.getDate(\"birthday\"))); list.add(user); &#125; // 打印 for(User u : list)&#123; System.out.println(u.toString()); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; DBUtils.close(conn, rs, stmt); &#125;&#125; 将数据封装成的模型起码要保存数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class User &#123; private int id; private String name; private String password; private String email; private Date birthday; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public String getPassword() &#123; return password; &#125; public String getEmail() &#123; return email; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String toString()&#123; return id + \" \" + name + \" \" + password + \" \" + email + \" \" + birthday; &#125;&#125; SQL注入如果把占位符换成字符串变量，用拼接的方法完成sql语句，会有注入的问题。 这个问题就是，如果输入的字符串利用了sql语句的规则成为了字符串的一部分，导致信息校验出现问题（比如查询出不存在的数据）。被注入了其它的sql语句进来。 解决办法就是使用预加载Statement和占位符。","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/categories/JDBC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"操作系统笔记（一）","slug":"操作系统笔记-1","date":"2019-10-06T05:10:00.000Z","updated":"2019-10-09T12:11:01.922Z","comments":true,"path":"2019/10/06/操作系统笔记-1/","link":"","permalink":"http://yoursite.com/2019/10/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-1/","excerpt":"操作系统的启动刚上电时，操作系统在硬盘中。计算机工作原理是不断地取值执行，要取值执行，就要将代码放到内存中。一开始操作系统在硬盘上，无法取值执行。所以第一部分工作就是将操作系统从硬盘上载入到内存里。这些工作由操作系统的引导扇区来完成，也就是bootsect.s，这是一段汇编程序。","text":"操作系统的启动刚上电时，操作系统在硬盘中。计算机工作原理是不断地取值执行，要取值执行，就要将代码放到内存中。一开始操作系统在硬盘上，无法取值执行。所以第一部分工作就是将操作系统从硬盘上载入到内存里。这些工作由操作系统的引导扇区来完成，也就是bootsect.s，这是一段汇编程序。 bootsect.s： 读入setup。 在屏幕上打出logo。 调用13号中断，读入system。 setup.s：完成OS启动前的设置。获得计算机的硬件信息，形成数据结构来管理这些设备。 int 0x15中断，获取内存大小。为了让操作系统知道内存有多大，才可以去管理。 操作系统挪动到从0地址开始的一系列内存。 mov cr0,ax，进入保护模式，即从16位（实模式）切换到32位的寻址方式。cr0这个寄存器的最后一位PE如果是0则为16位模式，是1则为32位模式。 在保护模式下的地址翻译： 地址翻译：全局描述符表GDT(Global Descriptor Table)，在硬件中完成，速度快。 CS不再是左移，而是变为了选择子，存放的是表的下标，表的索引。内存地址=根据CS查表+ip。 jmpi 0,8，CS=8，ip=0。跳到了head.s 接下来要跳到system模块中执行了，system由许多文件编译而成。第一部分是head.s。 关于汇编： as86汇编：能产生16位代码的Intel 8086(386)汇编。 GNU as汇编：产生32 位代码，使用AT&amp;T系统V语法。 内嵌汇编，gcc编译x.c会产生中间结果as汇编文件x.s。 head.s初始化一些表，跳出来到main.c。main.c中引用了mem_init函数，这个函数是用来初始化内存。 以上步骤完成了两件事情：将操作系统读进内存和初始化（读取硬件信息等）操作系统。 操作系统的接口信号转换，屏蔽细节。 命令行是怎么回事？命令输入后发生了什么？ 命令是一个用C语言写的程序。 图形按钮是怎么回事？ 消息框架程序 + 消息处理程序。 操作系统接口：通过c程序连接操作系统和应用软件。例如：fork。 操作系统提供这样的重要函数。这种重要函数就是操作系统接口：接口表现为函数调用，又由系统提供，所以称为系统调用(system_call)。 系统调用的实现如果可以随意调用的话计算机会很不安全，所以要将内核程序和用户隔离。内存分为内核段和用户段。 硬件提供了主动进入内核的方法：int 0x80中断。 （待补完） 操作系统历史IBM7094： 计算机使用原则：只专注于计算。 批处理操作系统(Batch system)：一个作业完成，自动读入下一个作业。 典型代表：IBSYS监控系统。 OS/360：计算机进入各种行业，一台计算机要应对不同的使用场景。 多道程序(multiprogramming)：多个任务同时出现，交替进行。 作业之间的千幻和调度成为核心。 多进程结构和进程管理概念萌芽。 MUTICS：使用人数增加。 每人启动一个作业，作业之间快速切换。 分时系统(timesharing)：分时切换。 核心仍然是任务切换，但是资源复用的思想会操作系统影响很大，虚拟内存就是一种复用。 UNIX：简化的MUTICS，核心概念差不多，但更加灵活和成功。1969年贝尔实验室的两个人开发了UNIX。 Linux：1981年推出的IBM PC。开源。 多进程结构是操作系统的基本图谱。 DOS： 1975年出现了CP/M。写命令让用户用，执行对应的程序，单任务。 1980，在CP/M的基础上开发了QDOS。 MS-DOS：1981，MS-DOS。 Windows：文件，开发环境，图形界面对于OS的重要性。 对用户的使用感受更加重视了。 cpu管理的直观想法 cpu的工作原理：自动的取值执行。 因为IO指令非常耗时（与计算指令相比），在一个程序执行IO指令时，可以执行其他程序。就形成了多道程序交替执行。 一个cpu上交替执行多个程序：并发。 怎么做到并发呢？ 需要记住切换执行时，程序原来的样子。用PCB存储。 进程：进行中的程序。 进程有开始，有结束，程序没有。 进程会走走停停，走停对程序无意义。 进程要记录离开进程时进程的样子，ax，bx。。 多进程图像操作系统只需要把这些资源记录好、要按照合理的次序推进（分配资源、进行调度），这就是多进程图像。 用户使用计算机就是启动了一堆进程，用户管理计算机就是管理进程。 多进程如何组织和存放进程？ Process Control Block：用来记录进程信息的数据结构。 运行→等待；运行→就绪；就绪→运行。。。 多进程如何交替？ 启动进程，启动磁盘读写，将进程设为阻塞态，放入等待队列中。启动schedule()切换函数。 getNext函数（调度函数）在就绪队列中找到下一个启动的线程，switch_to函数切换进程，保存当前线程，执行下一个线程。 多个进程如何相互影响？ 不同进程有可能会使用同一个内存。 解决方法：映射表。这是一种内存管理的方法。不同进程如果要访问同一个地址，可以用映射表把这个地址变成不同的物理地址。 多个进程之间如何合作？ 在打印工作中，多个进程想要打印，如果不做处理多个进程交替进行打印任务，就会出现问题。 解决方法：进程同步。给多个进程需要操作的公共资源上锁。第一个进程上锁，第二个进程想要执行的时候先检查锁，解锁后再执行。 用户级线程线程：保留了并发的优点，避免了简称切换的代价。一个进程中有多个线程，而这些进程的资源是公用的，使切换速度更快。现在讨论的切换都是线程的切换而不是进程的切换。 create函数同时启动多个线程，线程可以通过yield函数主动切换到第二个线程。 两个线程公用一个栈的话，我们会发现程序的运行顺序会出现问题。为此我们需要给一个线程用一个栈，在调用yield时会切换esp寄存器（用来存放栈顶指针的寄存器，记录在tcb中，一个线程一个tcb）的值。 内核级线程多核cpu如果想发挥作用，必须支持核心级线程。 这里是多对多的：多个线程和多个核，由操作系统调配。 核心级线程与用户级有什么不同？ 切换时切换的是两套站栈。包括用户栈和内核栈。 这时tcp会记录用户栈与内核栈。 用户栈和内核栈之间的关联： 通过中断进入内核栈，通过IRET返回用户栈。 进入内核时，内核栈中压入对应用户栈的SS和SP（栈地址）、CS和IP（指令地址）。 内核栈中记录了如何找到用户栈的信息。 内核switch_to的五段论： 进入中断。 中断处理：启动磁盘读或时钟中断，引发切换。 找到下个要执行的tcb。 根据tcb完成内核栈的切换。 IRET切换到用户栈。 所以在创建线程时，就需要创建用户栈、内核栈、tcb。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"汇编笔记（一）","slug":"汇编笔记 I","date":"2019-09-28T02:07:51.000Z","updated":"2019-10-06T05:11:28.617Z","comments":true,"path":"2019/09/28/汇编笔记 I/","link":"","permalink":"http://yoursite.com/2019/09/28/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%20I/","excerpt":"1 基础知识汇编语言产生于机器语言的过于复杂和难以记忆。 汇编指令通过编译器编译为机器码后，计算机才可以理解。","text":"1 基础知识汇编语言产生于机器语言的过于复杂和难以记忆。 汇编指令通过编译器编译为机器码后，计算机才可以理解。 2 寄存器：CPU工作原理2.1 通用寄存器16位寄存器可以放两个字节。AX BX CX DX通常被用来存放一般性的数据，被称为通用寄存器。 AX：由低到高填入二进制数，空位补零。 16位寄存器储存的最大数：2^16-1。 存在8位寄存器，为了兼容8位寄存器，一个16位的寄存器可以分为两个独立的8位寄存器使用。AX可以分为AH(high)高地址和AL(low)低地址。 2.2 字在寄存器中的存储一个字占两个字节，一个字节8位。一个内存单元是8位。 2.3 几条汇编指令语法：不分大小写。 mov ax,18：将18这个值赋给ax寄存器。 ax = 18 add ax,8：将ax中的数值+8。 ax += 8 add ax,bx：将ax，bx中的内容相加，结果存在ax中。 如果相加的结果大于16位，多出部分会放到别的地方。 2.4 物理地址cpu访问内存单元时要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间。这个唯一的地址称为物理地址。 2.5 16位的cpu16位cpu具有一下三方面的特点： 运算器以此作多可以处理16位的数据。 寄存器的最大宽度是16位。 寄存器和运算器之间的通路是16位。 （且cpu位数等于数据总线的条数） 2.6 8086cpu给出物理地址的方法8086的地址总线位20位，内部位16位，寻址能力并不相同。它采用了一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。 16位段地址 + 16位偏移地址 –&gt; 经过地址加法器 –&gt; 生成20位地址 具体过程：段地址*16(16进制左移一位)，在于偏移地址相加，得到20位地址。 生成同一个地址，可能有多种段地址和偏移地址的组合。 2.72.8 段的概念在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址*16定位段的起使地址（基础地址），用偏移地址定位段中的内存单元。 段地址*16必然是16的倍数，所以一个短的起始地址也一定是16的倍数； 偏移地址位16位，16位地址的寻址能力位64K，所以一个段的长度最大为64K。范围为：0~FFFFH。 2000段中的1F60H单元 = 2000:1F60单元。 2.9 段寄存器CS(code segment) 代码段寄存器： DS(data segment) 数据段寄存器 SS(stact segment) 栈段寄存器 ES(extra segment) 额外段寄存器 为8086的4个段寄存器。当8086要访问内存时，由这4个段寄存器提供内存的单元的段地址。 2.10 CS和IPCS(code segment) 代码段寄存器： 指示了cpu当前要读取指令的地址。 CS为代码段寄存器。 IP为指令指针寄存器（偏移寄存器）。 步骤： 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器（准备执行）; IP = IP + 读取指令的长度，从而指向下一条指令; 执行指令，回到步骤1，重复。 8086pc工作的简要描述： 在加电启动或复位后，CS和IP被设置为CS=FFFFH，IP=0000H; cpu从内存FFFF0H单元中读取指令执行。 FFFF0H端元中的指令是8086开机后执行的第一条指令。 如果说，内存中的一段信息曾被cpu执行过，那么它所在的内存单元必定被CS:IP指向过。 2.11 修改CS IP的指令程序员可以通过使用jmp指令改变CS IP中的内容控制cpu执行的目标指令。 jmp 2000:2AE3：修改CS和IP。 jmp ax：将ax的值赋给IP，只修改IP的值。 2.12 代码段可以将长度小于64K的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存用来存放代码，从而定义了一个代码段。 只有被CS:IP指向的内存单元中的内容才会被cpu认为是指令。用DS会被理解为数据。 要将CS:IP指向代码段的第一条指令。 3 寄存器：内存访问3.1 内存中字的存储一个地址单元放一个字节，8位。一个字型数据站两个字节，也就是两个地址单元。 任何两个地址连续的内存单元，n号单元和n+1号单元，可以将它们堪称两个内存单元，也可以看成一个地址为n的字单元中的高位字节单元和低位字节单元。 3.2 DS和[address]1234# 将字节数据从内存单元送入寄存器mov bx,1000H;mov ds,bx;mov al,[0]; ds中的1000H是段地址，[ ]中是偏移地址。上面三条指令将1000:0中的数据读到al中。 不可以直接给ds段寄存器赋值。 在从内存中取值之前，在ds里设置好段地址，取值时用[ ]写偏移地址。 1234# 将字节数据从寄存器送入内存单元mov bx,1000H;mov ds,bx;mov [0],al; 3.3 字的传送1234mov bx,1000H;mov ds,bx;mov ax,[0]; #1000:0处的字形数据送入axmov [0],cx; #cx中的16位数据送到1000:0 3.4 mov、add、sub指令mov指令的几种形式： mov 寄存器，数据 mov 寄存器，寄存器 mov 寄存器，内存单元 mov 内存单元，寄存器 mov 段寄存器，寄存器 mov 寄存器，段寄存器 add和sub指令同mov一样，都有两个操作对象。但是它们两个不可以操作段寄存器。因为段寄存器无法进行四则运算。 3.5 数据段可以根据需要将一组内存单元定义为一个段（可以是代码段、数据段等）。必须是16的倍数。 3.6 栈栈是一种具有特殊访问方式的数据存储空间。先进后出。 3.7 cpu提供的栈机制PUSH（入栈）ax：将寄存器ax中的数据送入栈中。 POP（出栈）ax：从栈顶取出数据ax。 cpu如何找到栈顶元素的位置？通过SS:SP找到栈顶元素的地址。 PUSH的过程：SP = SP - 2，然后将数据送入SP指向的内存单元处。 POP的过程：将SP指向位置的数据取出来，然后SP = SP + 2。 空栈时，SP指向最高地址单元的下一个地址。","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数据库基础笔记","slug":"数据库基础笔记","date":"2019-08-23T07:04:22.000Z","updated":"2019-08-23T07:06:04.144Z","comments":true,"path":"2019/08/23/数据库基础笔记/","link":"","permalink":"http://yoursite.com/2019/08/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","excerpt":"数据库的基本概念DataBase：数据库，用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。数据库就是一个文件系统。 方便存储的管理数据。 使用了统一的方式来操作数据库——SQL。 常用的数据库软件： Oracle 收费 MySQL Microsoft SQL Server 收费 DB2","text":"数据库的基本概念DataBase：数据库，用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。数据库就是一个文件系统。 方便存储的管理数据。 使用了统一的方式来操作数据库——SQL。 常用的数据库软件： Oracle 收费 MySQL Microsoft SQL Server 收费 DB2 MySQL数据库软件安装卸载 卸载。 删除C:/ProgramData文件夹下的MySQL文件夹。 配置服务：没有界面的应用程序。 开启和停止的两种方法： 在命令提示符中使用services.msc命令查看服务，选择开启或者停止MySQL服务。 以管理员运行命令提示符，使用net start mysql55开启服务，或使用net stop mysql55停止MySQL服务。 MySQL登陆：mysql -uroot -p 远程登陆：mysql -h连接目标ip -uroot -p连接目标密码 mysql --host=ip --user=root --password=连接目标的密码 MySQL退出：exit quit MySQL目录结构： MySQL安装目录 bin：二进制的可执行文件 data：日志文件，数据文件 include：c语言的头文件 lib：jar包 share：错误信息 MYSQL数据目录：C:/ProgramData/MySQL、 数据库：文件夹 表：文件 数据 SQLStructured Query Language：结构化查询语言。 定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为”方言“ SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3种注释： 单行注释：– 注释内容 或 #注释内容（MySQL特有） 多行注释：/* 注释内容 */ SQL分类 DDL(Data Definition Language)数据定义语言 ​ 用来定义数据库对象：数据库，表，列等。关键字：create，drop，alter 等。 DML(Data Manipulation Language)数据操作语言 ​ 用来对数据库种表的数据进行增删改。关键字：insert，delete，update 等。 DQL(Data Query Language)数据查询语言 ​ 用来查询数据库中表的记录（数据）。关键字：select，where 等。 DCL(Data Control Language)数据控制语言 ​ 授权。 DDL：操作数据库、表 操作数据库：CRUD C(Create)：创建 CREATE DATABASE 数据库名称;：创建数据库。 CREATE DATABASE 数据库名称 CHARACTER SET GBK;：创建指定字符集的数据库。（gbk）。 CREATE DATABASE IF NOT EXISTS 数据库名称 CHARACTER SET GBK;：判断数据库是否存在后创建指定字符集的数据库。 R(Retrieve)：查询 SHOW DATABASES;：查询所有数据库的名称。 SHOW CREATE DATABASE 数据库名称;：查看某个数据库的字符集，查询某个数据库的创建语句。 U(Update)：修改 ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;：修改数据库的字符集。 D(Delete)：删除 DROP DATABASE 数据库名称; DROP DATABASE IF EXISTS 数据库名称; 使用数据库: SELECT DATABASE();：查询当前正在使用的数据库名称。 USE 数据库名称：使用（进入）到数据库中。 操作表 C(Create)：创建 语法： 123456789101112131415161718CREATE TABLE 表名( 列名1 数据类型1， 列名2 数据类型2， age int, score double(5,2), -- 999.99 name varchar(20), -- 字符串长度最大20个字符 ...列名n 数据类型n)CREATE TABLE STUDENT( ID INT, NAME VARCHAR(32), AGE INT, ACORE DOUBLE(4,1), BIRTHDAY DATE, INSERT_TIME TIMESTAMP); 数据库类型： int：整数类型。 double：小数类型。 date：日期，只包含年月日，yyyy-MM-dd。 datetime：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss。 timestamp：时间戳类型。包含年月日时分秒，yyyy-MM-dd HH:mm:ss。如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值。 varchar：字符串 CREATE TABLE 表名1 LIKE 表名2;：创建一个和表2一样的表1。 R(Retrieve)：查询 SHOW TABLES;：查询某个数据库中所有表的名称。 DESC 表名;：查询表结构。 U(Update)：修改 ALTER TABLE 表名 RENAME TO 新表名;：修改表名。 ALTER TABLE 表名 CHARACTER SET 字符集名称;：修改表的字符集。 ALTER TABLE 表名 ADD 列名;：添加列。 ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型; ALTER TABLE 表名 MODIFY 列名 新数据类型;：修改列名称/类型。 ALTER TABLE 表名 DROP 列名;：删除列。 D(Delete)：删除 DROP TABLE 表名; DROP TABLE IF EXISTS 表名; TRUNCATE TABLE 表名：删除表，然后创建一张相同的空表。 DML：增删改表中的数据 添加数据： INSERT INTO 表名(列名1,列名2, ... ,列名n) VALUES(值1,&#39;Mike&#39;, ... ,&#39;1999-1-1&#39;); 注意： 列名和值要一一对应。 如果表名后，不定义列名，则默认给所有列添加值。 INSERT INTO 表名 VALUES(值1,值2, ... ,值n); 除了数字类型，其他类型需要用引号引起来，单双都可。 删除数据 DELETE FROM 表名 [WHERE 条件]; 注意： 如果不加条件，会把表中的所有记录都删除掉。 如果要删除所有记录 DELETE FROM 表名; – 不推荐使用。效率低。 TRUNCATE TABLE 表名; – 推荐使用，效率更高。删除表，然后创建一张相同的空表。 修改数据 UPDATE 表名 SET 列名1=值1, 列名2=值2, ... [WHERE 条件]; 注意： 如果不加任何条件，将会把表中的所有数据都进行修改。 DQL：查询表中的记录 SELECT * FROM 表名：查询表中的所有记录。","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/categories/DataBase/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Servlet基础","slug":"Servlet基础","date":"2019-07-24T01:29:29.000Z","updated":"2019-07-24T01:30:28.052Z","comments":true,"path":"2019/07/24/Servlet基础/","link":"","permalink":"http://yoursite.com/2019/07/24/Servlet%E5%9F%BA%E7%A1%80/","excerpt":"概念Server applet：运行在服务器端的小程序。它是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则。我们在自定义类的时候，要实现Servlet接口，复写方法。","text":"概念Server applet：运行在服务器端的小程序。它是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则。我们在自定义类的时候，要实现Servlet接口，复写方法。 快速入门 创建JavaEE项目 定义实现Servlet的类 1public class ServletDemo1 implements Servlet&#123;&#125; 实现接口中的抽象方法 配置Servlet 在web.xml的web-app标签中如下配置： 12345678910&lt;!--配置Servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;web.servlet.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet执行原理 当服务器接收到客户端的请求后，会解析请求URL路径，获取访问的Servlet的资源路径。 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 如果有，则再找到对应的&lt;servlet-class&gt;全类名。 tomcat会将字节码文件加载进内存，并创建其对象。 调用其方法。 Servlet中的生命周期 被创建：执行init方法，只执行一次。 Servlet什么时候被创建？ 默认情况下是第一次被访问时，Servlet被创建。我们可以配置执行Servlet的创建时机。 在web.xml的&lt;servlet&gt;标签下配置。 第一次被访问时创建 &lt;load-on-startup&gt;的值为负数 在服务器启动时创建 &lt;load-on-startup&gt;的值为0或正整数 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。多个用户同时访问时，可能存在线程安全问题。解决方法是尽量不要在Servlet中定于i成员变量。即使定义了成员变量，也不要修改值。 提供服务：执行servlet方法，执行多次。 被销毁：执行destroy方法，执行一次。 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源。 Servlet 3.0支持注解配置。可以不用web.xml.了。 步骤： 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml。 定义一个类，实现Servlet接口。 复写方法。 在类上使用@WebServlet注解，如下进行配置： @WebServlet(&quot;/资源路径) 这个注解中有多个配置，其中value与urlPatterns相关联。只写一个配置时，value可以省略不写。 123456789101112131415@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet&#123; String name default \"\";// 相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;// 代表urlPatterns()属性配置 String[] urlPatterns() defualt -1;// 相当于&lt;url-pattern&gt; int loadOnStarup() default -1;// 相当于&lt;load-on-startup&gt; WebInitParam[] initParams() defalut &#123;&#125;; boolean asyncSupported() default false; String smallIcon default \"\"; String largecon default \"\"; String description() default \"\"; String displayName() default \"\";&#125; IDEA与Tomcat的相关配置 IDEA会为每一个Tomcat部署的项目单独建立一份配置文件。 查看控制台的log：Using CATALINA_BASE: &quot;C:\\Users\\Retur0\\.IntelliJIdea2019.1\\system\\tomcat\\_Tomcat_IDEA&quot; 工作空间项目 和 tomcat的web项目。 tomcat真正访问的是：“tomcat的web项目”。 “tomcat的web项目”对应着“工作空间项目”的web目录下的所有资源。 web-INF目录下的资源不能被浏览器直接访问。 断点调试：使用IDEA中的debug启动 Servlet体系结构Servlet — 接口 |GenericServlet — 抽象类 |HttpServlet — 抽象类 GenericServlet：将Servlet接口中的其他方法做了默认空实现，只将service()方法作为抽象。将来定义Servlet类时，可以继承GenericServlet，实现Service方法即可。 HttpServlet：对http协议的一种封装，简化操作。 定义类来继承HttpServlet 复写doGet/doPost方法 Servlet相关配置 urlPatterns： servlet访问路径。一个servlet可以定义多个访问路径。 路径的定义规则： /xxx /xxx/xxx：目录结构，多层路径。 *.do：自定义扩展名，通过扩展名找到文件。","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Tomcat基础知识","slug":"Tomcat笔记","date":"2019-07-22T15:04:05.000Z","updated":"2019-07-23T00:50:55.786Z","comments":true,"path":"2019/07/22/Tomcat笔记/","link":"","permalink":"http://yoursite.com/2019/07/22/Tomcat%E7%AC%94%E8%AE%B0/","excerpt":"Web服务器软件服务器：安装了服务器软件的计算机。 服务器软件：接收用户的请求，处理请求，做出相应。 Web服务器软件：接收用户的请求，处理请求，做出相应。可以部署Web项目，让用户通过浏览器来访问这些项目。也被称为Web容器。 常见的Java相关的Web服务器软件： webLogic：Oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 JavaEE是Java语言在企业级开发中使用的技术规范综合，一共规定了13项大的规范。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 JBOSS：JBOSS公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 TomCat：Apache基金组织，中小型JavaEE服务器，仅仅支持少量的JavaEE规范。开源免费。","text":"Web服务器软件服务器：安装了服务器软件的计算机。 服务器软件：接收用户的请求，处理请求，做出相应。 Web服务器软件：接收用户的请求，处理请求，做出相应。可以部署Web项目，让用户通过浏览器来访问这些项目。也被称为Web容器。 常见的Java相关的Web服务器软件： webLogic：Oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 JavaEE是Java语言在企业级开发中使用的技术规范综合，一共规定了13项大的规范。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 JBOSS：JBOSS公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 TomCat：Apache基金组织，中小型JavaEE服务器，仅仅支持少量的JavaEE规范。开源免费。 Tomcat 安装 https://tomcat.apache.org/ 解压压缩包。安装目录不要有中文和空格。 目录： bin —————— 可执行文件 conf —————- 配置文件 lib ——————- Tomcat启动所依赖的jar包 logs —————- 日志文件 temp ————— 临时文件 webapps ——— 存放web项目 work —————- 存放运行时的数据 启动：bin/startup.bat 启动时可能出现的问题： 闪退：没有正确配置JAVA_HOME环境变量。 启动报错：端口被占用。 杀死占8080端口的程序。可以使用下面这个命令查看计算机上的端口使用情况： netstat -ano 找到占用8080端口的程序对应的PID，在任务管理器的查看进程中找到这个的PID，结束进程。 或者改变Tomcat的端口号 找到Tomcat目录下的conf/server.xml配置文件，改变port=&quot;8080&quot;等一系列port。 淇℃伅 找到Tomcat目录下的conf/logging.properties配置文件，打开，搜索java.util.logging.ConsoleHandler.encoding，将UTF-8改为GBK。loggin.properties配置文件里面有好多的encoding值，以后遇到和Tomcat有关的编码问题时就可以来检查一下这个文件。 访问：ip地址:8080。localhost表示本机ip。 关闭 正常关闭：shutdown.bat或者ctrl+c。 强制关闭：点x。 配置 部署项目的方式： 直接将项放到webapps目录下即可。localhost:8080/hello/hello.html /hello：项目的访问路径。 简化部署：将项目压缩成war包，再将war包放到webapps目录下。war包会自动解压缩。 配置conf/server.xml文件，在&lt;host&gt;标签体中配置： &lt;Contest docBase=&quot; &quot; path=&quot; &quot;/&gt; docBase：项目存放的路径，path：虚拟目录。 在conf/Catalina/localhost创建任意名称的xml文件。在文件中配置： &lt;Contest docBase=&quot; &quot;&gt; 虚拟目录为xml文件的名称。 静态项目和动态项目 目录结构： Java动态项目的目录结构： –项目根目录 ​ –WEB-INF目录 ​ –web.xml：web项目核心配置文件 ​ –classes：放置字节码文件目录 ​ –lib：放置依赖的jar包 将Tomcat集成到IDEA中并创建JavaEE项目","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/categories/Tomcat/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"JS基础知识","slug":"JS笔记","date":"2019-07-18T08:10:09.000Z","updated":"2019-07-19T22:56:23.397Z","comments":true,"path":"2019/07/18/JS笔记/","link":"","permalink":"http://yoursite.com/2019/07/18/JS%E7%AC%94%E8%AE%B0/","excerpt":"概念一门客户端脚本语言。它是运行在客户端浏览器中的，每一个浏览器都有JavaScript的解析引擎。 脚本（script）语言：不需要编译，直接就可以被浏览器解析执行。","text":"概念一门客户端脚本语言。它是运行在客户端浏览器中的，每一个浏览器都有JavaScript的解析引擎。 脚本（script）语言：不需要编译，直接就可以被浏览器解析执行。 功能可以增强用户和HTML页面交互的过程，可以来控制HTML元素，让页面有一些动态的效果，增强用户的体验。 JS发展史 1992：Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验 。命名为c–，后来更名为ScriptEase。 1995：Netscape公司，开发了一门客户端脚本语言：LiveScript。后来请来了SUN公司，修改LiveScript，命名为JavaScript。 1996：微软抄袭了JavaScript开发出了JScript语言。 1997：ECMA（欧洲计算机制造商协会）制定了ECMAScript，所有客户端脚本语言的标准。 JavaScript = ECMAScript + JavaScript中的BOM和DOM ECMAScript基本语法和HTML结合方式 内部JS：定义&lt;script&gt;，标签体内容就是JS代码 外部JS：定义&lt;script&gt;，通过src属性引入外部的JS文件 注意： &lt;script&gt;可以定义在HTML页面的任何地方。但是定义的位置会影响执行顺序 &lt;script&gt;可以定义多个 注释 单行注释：// 注释内容 多行注释：/*注释内容*/ 数据类型 原始数据类型（基本数据类型）： number：数字。整数/小数/NaN（not a number 一个不是数字的数字类型） string：字符串。&quot;abc&quot; &quot;a&quot; &#39;abc&#39;，没有字符的概念 boolean null：空，占位符。typeof运算符对于null值会返回Object，这是一个被沿用的错误。现在，null被认为是对象的占位符，从而解释这一矛盾。 undefined：未定义。如果一个变量没有给初始化值，则会被赋值为undefined 引用数据类型：对象 变量一小块存储数据的内存空间。Java语言是强类型的语言，而JavaScript是一种弱类型的语言。强类型指某一个变量只能存储一种类型的数据。弱类型意为在申请内存的存储空间时，没有规定这片空间只能是某一特定类型。例如一个命名为 a 的变量，可以在储存完整数值之后，存储字符串。 语法：通过var关键字定义 var 变量名 = 初始化值； 运算符 一元运算符：只有一个运算数的运算符 ++，–，+（正） 算数运算符 赋值运算符 比较运算符 ==，===（全等于） 类型相同：直接比较 类型不同：先进行类型转换，再比较 ===：把类型也纳入比较范围中，类型不同则返回false 逻辑元算符 JS中，对象和字符串可以直接放到 if 中判断。若对象是null则为false，若字符串长度是0也为false。number为0或NaN为假，其他为真。 三元运算符 ？，： 流程控制语句 if…else… switch 在java中，switch可以接受的数据类型：byte, int, short, char, 枚举（1.5）, String（1.7） 在JS中，switch可以接收任意类型的数据 while do…while for JS特殊语法 语句以；结尾，如果一行只有一条语句则；可以省略 定义变量时可以省略var关键字。如果省略则表示这个变量是全局变量。不省略这个变量是局部变量 基本对象 Function：函数（方法）对象 创建： var fun = new Function(形式参数列表, 方法体); function 方法名称(形式参数列表){ 方法体 } var 方法名 = function(形式参数列表) { 方法体 } 方法： 属性： length：形参的个数 特点： 方法定义时，形参的类型不用写，返回值类型也不写 方法是一个对象，如果定义名称相同，后定义的会把先定义的覆盖掉 方法的调用只和方法的名称有关，和参数列表无关 在方法声明中，有一个隐藏的内置对象（数组），arguments，封装所有的实际参数 调用： 方法名称(实际参数列表) Array：数组对象 创建 var arr = new Array(元素列表) var arr = new Array(默认长度) var arr = [元素列表] 方法 join()：将数组中的元素，按照指定的分隔符，拼接为字符串 push()：向集合尾部添加元素 属性 length 特点 JS中数组元素的类型是可变的，数组长度也是可变的 Boolean Date 创建 var date = new date 方法： toLocaleString()： 返回date对象对应的事件本地字符串格式 getTime()：获取当前日期对象描述的时间到1970年1月1日的毫秒值差 Math：该对象不用创建，直接使用、 方法：查文档。Math.方法名() 属性 Number String RegExp：正则表达式对象 正则表达式：定义字符串组成规则 单个字符：[] 如：[a] [ab] [a - z] 特殊符号代表特殊含义的单个字符： \\d：单个数字字符[0 - 9] \\w：单个单词字符[a - zA - Z0 - 9_] 量词符号： ？：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m, n}：表示数量 &gt;=m 且 &lt;=n。m如果缺省：{, n} 最多n次。n如果缺省：{m, } 最少m次。 开始结束符号： ^：开始。 $：结束。 正则对象： 创建 var reg = new RegExp(&quot;正则表达式&quot;) var reg = /正则表达式/ 方法 test(参数)：验证指定的字符串是否符合正则定义的规范。符合返回true，不符合返回false。 Global 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。方法名(); 方法： 字符少 encodeURI：url编码。 decodeURI：url解码。 字符多 encodeURIComponent()：url编码。 encodeURIComponent()：url解码。 parseInt()：字符串转为数字。逐一判断每一个字符是否是数字，直到不是数字为止，将前面的数字部分转为int。 isNaN()：判断一个值是否为NaN。NaN无法直接比较，返回均是false。只有isNaN() 可以判断。 eval()：将JS的字符串转换为脚本执行。 URL编码 在UTF-8下，一个汉字对应3个字节。编码时，每一个字节由%和由一个字节（8位）的16进制表示组成。例如：传对应的编码是%E4%BC%A0。 BOMBrowser Object Model：浏览器对象模型。将浏览器的各个部分封装成对象。 Window：标签页对象 创建 方法 与弹出框有关的方法： alert()：显示带有一段消息和一个确认按钮的警告框。 confirm()：显示待有一段消息以及确认和取消按钮的对话框。点击确定返回true，点击取消返回false。 prompt()：显示可提示用户输入的对话框。返回用户输入的内容。 与打开关闭有关的方法： open()：打开新标签页。这个方法返回一个刚刚打开的标签页的Window对象。 close()：关闭当前标签页。 与定时器有关的方法： setTimeout ( JS代码或方法对象，毫秒值 )：在指定的毫秒数后调用函数或者计算表达式。 clearTimeout( id )：取消由 setTimeout() 方法设置的 timeout。在设置setTimeout时返回一个id。 setInterval( JS代码或方法对象，毫秒值 )：按照是定的周期（毫秒）来调用函数或计算表达式。 clearInterval() 属性 获取其他BOM对象： history location Navigator Screen 获取DOM对象 document 特点 Window对象不需要创建可以直接使用。window.方法名() Window引用可以省略。方法名() History：历史记录对象 创建：window.history history 方法： back()： forward() go() 属性：length 返回当前窗口历史列表中的URL数量 Location：地址栏对象 创建（获取）： window.location location 方法 reload()：刷新 属性 href：设置和返回完整的URL Navigator：浏览器对象 Screen：显示器对象 DOMDocument Object Model 文档对象模型。将标记语言文档的各个组成部分，封装成对象，可以使用这些对象，对标记语言文档进行CRUD（增删改查）的动态操作。 W3C DOM 标准被分为3个不同的部分： 核心 DOM：针对任何结构化文档的标准模型。 XML DOM：针对 XML 文档的标准模型。 HTML DOM：针对 HTML 的标准模型 核心DOM Document：文档对象 获取：在HTML DOM模型中可以使用window对象来获取。window.document document 方法： 获取Element对象： getElementById()：根据id属性值获取元素对象。id属性值一般唯一。 getElementsByTagName()：根据元素名称来获取元素对象们。返回值是一个数组。 getElementsByClassName()：根据class属性值获取元素对象们。返回值也是数组。 getElementsByName()：根据name属性值获取元素们。返回值也是数组。 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 属性 Element：元素对象 获取：通过document来获取和创建 方法： removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象，其他的5个父对象 特点：所有DOM对象都可以被认为是结点。 方法：CRUD DOM树的方法 appendChild()：向节点的子节点列表的结尾添加新的子节点。 removeChild()：删除（并返回）当前节点的指定子节点。不指定无法返回。 replaceChild()：用新节点替换一个子节点。 属性：parentNode 返回结点的父节点。 Attribute：属性对象 Text：文本对象 Comment：注释对象 HTML DOM 标签体的设置和获取：innerHTML 使用HTML元素对象的属性 控制元素样式 使用元素的style属性来设置元素对象.style.属性 = &quot;1px&quot; 提前定义好类选择器的样式，通过元素的className属性来设置其class属性。 事件监听机制某些组件被执行了某些操作后，触发某些代码被执行了。 事件：某些操作。如，单击，双击，键盘按下，鼠标移动 事件源：组件。如，文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发某个监听器代码。 常见的事件： 点击事件： onclick：单击事件。一般用于表单校验 ondbclick：双击事件 焦点事件： onblur：失去焦点 onfocus：元素获得焦点 加载事件： onload：一张页面或者一幅图像完成加载 鼠标事件： onmousedown 鼠标按钮被按下。定义方法时，定义一个对象，用于接收event对象。event对象的button属性可以返回是哪个鼠标按键被点击了。 onmouseup 鼠标按钮被松开 onmousemove 鼠标被移动 onmousebver 鼠标移动到某元素之上 onmouseout 鼠标从某元素移开 键盘事件： onkeydown 某个按键被按下 onkeyup 某个按键被松开 onkeypress 某个按键被按下并被松开 选择和改变： onchange 域的内容被改变 onselect 文本被选中 表单事件： onsubmit：确认按钮被点击 可以阻止表单的提交。方法返回false则表单不会被提交。 如果要组织表单提交，还可以再&lt;form&gt;标签添加onclick属性，并让onclick的键值为return 判断方法()，判断方法本身要返回布尔值。&lt;form ation=&#39;#&#39; iod=&#39;form&#39; onclick=&#39;return 判断方法();&#39; onreset：重置按钮被点击","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"CSS笔记","slug":"css笔记","date":"2019-07-11T13:17:27.000Z","updated":"2019-07-19T22:58:49.993Z","comments":true,"path":"2019/07/11/css笔记/","link":"","permalink":"http://yoursite.com/2019/07/11/css%E7%AC%94%E8%AE%B0/","excerpt":"CSS: 页面美化和布局控制概念：Cascading Style Sheets 层叠样式表层叠：多个样式可以作用在同一个HTML 的元素上，同时生效","text":"CSS: 页面美化和布局控制概念：Cascading Style Sheets 层叠样式表层叠：多个样式可以作用在同一个HTML 的元素上，同时生效 好处 功能强大 将内容的展示和样式控制分离 降低耦合度：解耦 让分工协作更容易 提高开发效率 CSS的使用：CSS与HTML结合方式、 内联样式 在标签中使用style属性制定css代码。这样，样式与内容展示还是偶合在一起 只作用当前标签 &lt;div style=&quot;color:red; &quot;&gt;hello css&lt;/div&gt; 内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 作用在当前页面 1234567&lt;style&gt; div&#123; color : blue; &#125; &lt;&#x2F;style&gt; &lt;div&gt;hello css&lt;&#x2F;div&gt; 外部样式 定义css资源文件 在head标签内，定义link标签，引入外部资源文件 1234567&lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;css&#x2F;a.css&#39;&gt;&lt;div&gt;hello css&lt;&#x2F;div&gt;a.css:div&#123; color : #c30000;&#125; 123三种方式，css作用的范围越来越大。1不常用，23常用 CSS语法 格式： 选择器 {​ 属性名１：属性值１​ 属性名２：属性名２} 选择器：筛选具有相似特征的元素 注意： 每一对属性需使用；隔开，最后一对属性可以不加 选择器筛选具有相似特征的元素 分类： 基础选择器 id选择器：选择具体的id属性值的元素,建议在一个html中id值唯一 语法：#id属性值{} 元素选择器：选择具有相同标签名称的元素 语法：标签名称{} 注意：id选择器优先级高于元素选择器 类选择器：选择具有相同class属性值的元素 语法：.class属性值{} 注意：类选择器的优先级高于元素选择器 扩展选择器 选择所有元素 语法：*{} 并集选择器 语法：选择器1,选择器2{} 子选择器：筛选选择器1下的选择器2元素 语法：选择器1 选择器2{} 父选择器：筛选选择器2的父元素选择器1 语法：选择器1 &gt; 选择器2{} 属性选择器：选择元素名称，属性名=元素值的元素 语法：元素名称[属性名=‘属性值’]{} 伪类选择器：选择一些元素具有的状态 语法：元素:状态{} 如：&lt;a&gt; 状态： link：初始化的状态 visted：被访问过的状态 active：正在访问的状态 hover：鼠标悬浮状态 属性 字体、文本 font-size：字体大小 color：文本颜色 text-align：对齐方式 line-height：行高 背景 background：设置背景，复合属性 边框 border：设置边框，复合属性。还可以分别设置每一个属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下，内边距会影响整个盒子的大小 box-sizing: border-box：设置盒子的属性，让width和height不会变化 float： left right","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"HTML笔记","slug":"html笔记","date":"2019-07-11T13:17:18.000Z","updated":"2019-07-18T08:11:59.935Z","comments":true,"path":"2019/07/11/html笔记/","link":"","permalink":"http://yoursite.com/2019/07/11/html%E7%AC%94%E8%AE%B0/","excerpt":"内容概述121. Web概念概述2. HTML Web概念概述Java Web 使用Java语言开发基于互联网的项目","text":"内容概述121. Web概念概述2. HTML Web概念概述Java Web 使用Java语言开发基于互联网的项目 软件架构 C/S: Client/Server 客户端/服务器端 在用户本地有一个客户端程序，在远程有一个服务器端程序 优点：用户体验好 缺点：开发、安装、部署、维护麻烦 B/S: Browser/Server 浏览器/服务器 只需要一个浏览器，用户通过不同的网址（URL），客户访问不同的服务器端程序 优点：开发、安装、部署、维护简单 缺点：如果应用过大，用户体验会受到影响。对硬件要求过高：服务器，带宽 B/S 架构详解 资源分类： 静态资源：使用静态网页开发技术发布的资源 特点： 所有用户访问，看到的效果是一样的 如：文本，图片，音频，视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以来展示这些静态资源 HTML：用于搭建基础网页，展示页面的内容 CSS：美化页面，布局页面 JavaScript：控制页面的元素，是页面有一些动态的效果 动态资源：使用动态网页及时发布的资源 特点： 每个访问的用户得到的结果可能不同 如：jsp/servlet, php, asp 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 我们要学习动态资源，必须先学习静态资源 HTML概念 是最基础的网页开发语言。 Hyper Text Markup Language 超文本标记语言 超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言：由标签构成的语言 &lt;标签名称&gt; 如HTML，XML 标记语言不是编程语言 入门语法 HTML后缀名 .html 或者 .htm 标签分为： 围堵标签：有开始标签和结束标签 自闭合标签 标签可以嵌套：需要正确嵌套，不能交叉 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号（单双都可以）引起来 html 的标签不区分大小写，但是建议使用小写 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;这是title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;front color='red'&gt;Hello,World&lt;/front&gt;&lt;br/&gt; &lt;front color='green'&gt;Hello,World&lt;/front&gt; &lt;/body&gt;&lt;/html&gt; 标签文件标签：构成html最基本的标签 html：html文档的跟标签 head：头标签。用于指定html文档的一些属性，引入外部的资源 title：标题标签 body：网页的主体 &lt;!DOCTYPE html&gt;：html5 中定义该文档是 html 文档 文本标签：和文本有关的标签 注释：&lt;!-- 注释内容 --&gt; &lt;h1&gt; - &lt;h6&gt;：标题标签。字体大小递减 &lt;p&gt;：段落标签 &lt;br/&gt;：换行 &lt;hr color=&#39;&#39;/&gt;：一条水平线 color width size align：对齐方式（center/left/right） &lt;b&gt;：加粗 &lt;i&gt;：斜体 &lt;font&gt;：字体 color size face：字体 属性定义： color： 英文单词 RGB( 0255, 0255, 0~255 ) #值1值2值3：00~FF 之间，#FFFFFF 白 width： 数值：width=’20’ ，单位为 px（像素） 数值%：在父元素中所占的比例 特殊字符： 显示结果 描述 代码表示 &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; 空格 &amp;nbsp; &amp; 和号 &amp;amp; “ 引号 &amp;quot; 图片标签 &lt;img sec=&#39;图片路径&#39; align=&#39;&#39; alt=&#39;图片替换信息&#39; /&gt; src路径写法： 相对路径，以 . 开头的路径 ./ : 表示当前目录，不写 ./ 的话默认加 ./ ../ : 表示上一级目录 列表标签： 有序列表： 12345678910&lt;ol type='a/1/I'&gt; &lt;li&gt;内容1&lt;/li&gt; &lt;li&gt;内容2&lt;/li&gt; &lt;li&gt;内容3&lt;/li&gt;&lt;/ol&gt;&lt;ul type='disc/square/circle'&gt; &lt;li&gt;内容1&lt;/li&gt; &lt;li&gt;内容2&lt;/li&gt; &lt;li&gt;内容3&lt;/li&gt;&lt;/ul&gt; ol : orderlist li : 无序列表 ul : unorderLst li : 链接标签 &lt;a href=&#39;http://www.bilibili,com&#39; target=&#39;&#39;&gt;&lt;/a&gt; 属性： href = 指定访问资源的URL（统一资源定位符）。既可以是网络中的，也可以是本地项目中的 &#39;mailto:384878281@qq.com&#39;：给这个邮箱发邮件 target = _self：默认值，在本页面打开链接 _blank：在新标签页打开 使用&lt;a&gt;&lt;/a&gt;包裹&lt;img&gt;，达到点击图片跳转链接的目的 div 和 span： div：每一个div占满一整行。块级标签 span：文本信息在一行展示，行内标签，内联标签 语义化标签HTML5 中为了提高程序的可读性，提供了一些没有样式的标签，要结合CSS一起使用 header footer 表格标签 table：定义表格 属性：boder是否有边框，width表格宽度，cellpadding内容和边框之间的距离，cellspacing边框粗细，bgcolor背景色，align表格的对齐方式 tr：定义行 bgcolor：背景色 align：对齐方式 td：定义单元格 colspan：合并列 rowspan：合并行 th：定义表头单元格 caption：表格标题 thead：表示表格的头部分 tbody：表示表格的体部分 tfoot：表示表格的脚部分 123456789101112131415161718192021222324252627282930313233&lt;table border='1' width='50%' cellpadding='4' cellspacing='0'&gt; &lt;thead&gt; &lt;caption&gt;学生信息表&lt;/caption&gt; &lt;!--第一行--&gt; &lt;tr&gt; &lt;th rowspan='2'&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!--第二行--&gt; &lt;tr&gt; &lt;td&gt;name01&lt;/td&gt; &lt;td&gt;70&lt;/td&gt; &lt;/tr&gt; &lt;!--第三行--&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td colspan='2'&gt;name02&lt;/td&gt; &lt;/tr&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;name03&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 表单标签 表单：用于采集用户输入的数据，用于和服务器进行交互 form：用于定义表单的。可以定义一个范围，范围代表次啊及用户数据的范围 属性： action：指定提交数据的URL method：指定提交方式，一共7种，两种比较常用： get： 请求参数会在地址栏中显示。会封装到请求行中 URL长度是有限制的 不太安全 post 请求参数不会在地址栏中显示。会封装在请求体中 URL长度是有没有限制的 较为安全 表单项中的数据要想被提交，必须指定其name属性 在提交时，name定义的是键值对的键，value定义的是键值对的值 1234567891011121314151617181920212223&lt;form action='#' method='get'&gt; &lt;lable for='username'&gt;用户名:&lt;/lable&gt;&lt;input type='text' name='username' placeholder='请输入用户名' id='username'&gt;&lt;br&gt; 密码:&lt;input type='password' name='password'&gt;&lt;br&gt; 性别:&lt;input type='radio' name='gender' value='male'&gt; 男 &lt;input type='radio' name='gender' value='female'&gt; 女 &lt;br&gt; 爱好:&lt;input type='checkbox' name='hobby' value='sing' checked='checked'&gt; 唱 &lt;input type='checkbox' name='hobby' value='dance'&gt; 跳 &lt;input type='checkbox' name='hobby' value='rap'&gt; Rap &lt;br&gt; 文件:&lt;input type='file' name='file'&gt;&lt;br&gt; 隐藏域:&lt;input type='hidden' name='id' value='***'&gt;&lt;br&gt; 拾色器:&lt;input type='color' name='color'&gt;&lt;br&gt; 生日:&lt;input type='date' name='birthday'&gt;&lt;br&gt; 生日:&lt;input type='datetime-local' name='birthday'&gt;&lt;br&gt; 邮箱:&lt;input type='mail' name='email'&gt; 年龄:&lt;input type='number' name='age'&gt; &lt;br&gt; &lt;input type='submit' value='登陆'&gt; &lt;input type='button' value='按钮'&gt; &lt;input type='image' src=''&gt;&lt;/form&gt; 表单项标签 input：可以通过type属性，改变元素展示的样式 type： text：文本输入框，默认值 placeholder：提示信息。当输入框内容发生变化，会清空 password：密码输入框。不显示输入的内容 radio：单选框 要想让多个单选框实现单选的效果，则多个单选框的name属性必须一样 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性可以让此选项默认被选中 checkbox：复选框 file：文件选择框 hidden：隐藏域，用于提交一些信息 color：取色器 date： 按钮： submit：提交按钮，用于提交一些信息 button：普通按钮 image：图片提交按钮，通过src属性指定图片的路径 label：指定输入项的文字描述信息 label的for属性一般会和input的id属性值对应。如果对应了，点击label，会让对应的input输入框获得焦点 select：下拉列表 textarea：文本域","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Junit_Reflect_Annotation","slug":"Junit-Reflect-Annotation","date":"2019-07-08T12:38:00.000Z","updated":"2019-07-18T08:14:32.609Z","comments":true,"path":"2019/07/08/Junit-Reflect-Annotation/","link":"","permalink":"http://yoursite.com/2019/07/08/Junit-Reflect-Annotation/","excerpt":"Junit 单元测试 测试分类 黑盒测试：只看输入与输出是否吻合 白盒测试：关注程序具体的执行流程","text":"Junit 单元测试 测试分类 黑盒测试：只看输入与输出是否吻合 白盒测试：关注程序具体的执行流程 Junit使用：白盒测试 步骤： 定义一个测试类（测试用例） 建议： 测试类名为被测试类名+Test 包名：xxx.xxx.xxx.test 定义测试方法：可以独立运行 建议： 方法名：test+测试的方法名 返回值：void 参数列表：空参 给方法加@Test 导入junit依赖环境 判定结果 一般使用断言操作来处理结果 Assert.assertEquals(期望的结果, 运算的结果） 补充： @Before：修饰的方法在测试方法之前自动执行 @After： 修饰的方法在测试方法之后自动执行 反射：框架设计的灵魂 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码。 反射：将类的各个部分封装为其他对象，这就是反射机制 好处： 可以在程序运行过程中操作这些对象。（比如编辑器中成员方法的提示） 可以解耦，提高程序的可扩展性 Java代码 在计算机中经历的3个阶段 Source 源代码阶段 Java源文件编译后产生的字节码文件包括三个部分，分别对应Java类中的成员变量、构造方法、成&gt;员方法。还有其他的如类名 Class 类对象阶段 通过类加载器将字节码文件加载到内存中去，通过Class类对象来描述字节码文件，分别使用 Field[] fields：Field类型的数组，来描述成员变量 Constructor[] cons：Constructor类型的数组，来描述构造方法 Method[] methods：Method类型的数组，来描述成员方法 Runtime 运行时阶段 类实例化 获取Class类对象的三种方式 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类。 类名.class：通多类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义 多用于对象的获取字节码的方式 同一个字节码文件(*class)在一次程序运行过程中，只会被加载一次，无论通过哪一种方式获取的Class对象都是同一个 Class对象功能 获取功能 获取成员变量们 Field[] getFields()：获取所有public修饰的成员变量 Field getField(String name)：获取指定名称的public修饰的成员变量 Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符 获取构造方法们 Constructor&lt;?&gt;[] getConsturctors() Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) Constructor&lt;?&gt;[] getDeclaredConsturctors() Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) 获取成员方法们 Method[] getMethods() Method[] getMethod(String name, 例：String.class) Method[] getDeclaredMethods() Method[] getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 获取类名 String getName() Field：成员变量 操作： 设置值：void set(Object obj, Object vaule) 获取值：get(Object obj) 忽略访问权限修饰符的安全检查：setAccessible(true) Constructor：构造方法 创建对象：T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 Method：方法对象 执行方法：Object invoke(Object obj, Object…参数) 获取方法名称：String getName()：获取方法名 案例： 需求：写一个“框架”，不能改变该类任何代码的前提下，可以帮我们创建任意类的对象，并执行其中的任意方法 实现： 配置文件 反射 步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载类文件进内存 创建对象 执行方法 注解 概念：说明程序的，给计算机看的 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举、是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用分类： 编写文档：通过代码里标识的注解生成文档 [ 生成doc文档 ] 代码分析：通过代码里标识的注解对代码进行分析 [ 使用反射 ] 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查 [ Override ] JDK中预定义的一些注解 @Override：检测被该注解标注的方法是否继承自父类（接口）的 @Deprecated：该注解标注的内容已过时 @SupperessWarnings(“all”)：压制警告 自定义注解 格式： 123456元注解public @interface 注解名称&#123; 属性列表 &#125; 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 public interface MyAnno extends java.lang.annotation.Annotation {} 属性：接口中的抽象方法 要求： 属性的返回值类型： ​ 基本数据类型 ​ String ​ 枚举 ​ 注解 ​ 以上类型的数组 定义了属性，在使用时需要给属性赋值 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值 如果只有一个属性需要赋值，并且属性的名称时value，则value可以省略，直接定义值即可 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}省略 元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值：TYPE：可以作用于类上 ​ METHOD：可以作用于方法上 1FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 123456789101112- @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到- @Documented：描述注解是否被抽取到API文档中- @Inherited：描述注解是否被子类继承 &#96;&#96;&#96;Java @Target(value &#x3D; &#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)&#x2F;&#x2F; 可以做用在类，方法，成员变量 @Retention(RetentionPolicy.RUNTIME)public @interface Anno&#123; &#125; 12 在程序中使用（解析）注解：获取注解中定义的属性值 获取注解定义的位置的对象（Class,Method,Field) 获取指定的注解 getAnnotation(Class)// 其实就是在内存中生成了一个该注解接口的子类实现对象 123456789// 在内存中public class ProImpl implments Pro&#123; public String className&#123; return 在使用注释时,给className属性的赋值 &#125; public String methodName()&#123; return 在使用注释时,给methodName属性的赋值 &#125;&#125; 调用注解中的抽象方法来获取注解中的属性值 1234567891011121314@Pro(className = \"Person\", methodName = \"eat\")public class ReflectAnno&#123; public static void main(String[] args) throws Exception&#123; // 1.解析注解 // 1.1 获取该类的文件码字节对象 Class&lt;ReflectAnno&gt; rac = ReflectAnno.class; // 2.获取上面的注解对象 // 其实就是在内存中生成了一个该注解接口的子类实现对象 Pro anno = rac.getAnnotation(Pro.class); // 3.调用注解对象中定义的抽象方法，获取返回值 String c = anno.className(); String m = anno.methodName(); &#125;&#125; 小结 大多是时候，我们会使用注解，而不是自定义注解 注解给谁用？ 编译器 解析程序 注解不是程序的一部分，可以理解为注解就是一个标签","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Node笔记","slug":"Node笔记","date":"2019-07-07T09:14:20.000Z","updated":"2019-11-25T10:17:29.138Z","comments":true,"path":"2019/07/07/Node笔记/","link":"","permalink":"http://yoursite.com/2019/07/07/Node%E7%AC%94%E8%AE%B0/","excerpt":"Node.js 介绍 为什么学习Node.js 企业需求 具有服务端开发经验 前端 front-end 后端 back-end 全栈开发工程师 全干 基本的网站开发能力 服务端 前端 运维部署 多人社区","text":"Node.js 介绍 为什么学习Node.js 企业需求 具有服务端开发经验 前端 front-end 后端 back-end 全栈开发工程师 全干 基本的网站开发能力 服务端 前端 运维部署 多人社区 Node.js 是什么 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 不是一门语言 不是库，不是框架 是一个 JavaScript 运行时环境 可以解析和执行 js 代码 以前只有浏览器可以解析执行 js 现在js可以完全脱离浏览器来运行 浏览器中的 js EcmaScript 基本的语法 if var function Object Array BOM DOM Node.js中的js 没有 BOM/DOM EcmaScript 服务端不处理页面 在Node这个js执行环境中为js提供了一些服务器级别的操作 API 例如文件的读写 网络服务的构建 网络通信 http 服务器 等处理。。 构建于 Chrome V8 引擎之上 代码只是又特定格式的字符串而已 引擎可以认识它，引擎可以解析和执行 V8 是目前公认的解析执行js代码最快最高效的 Node.js 的作者把 Chrome 中的 V8 引擎移植了出来，开发了了一个独立的js运行时环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 event-driven 事件驱动 non-blocking I/O model 非阻塞IO模型（异步） lightweight and efficient 轻量与高效 Node.js 包生态系统，npm (node package management) 是世界上最大的开源库生态系统 绝大多数js相关的包都存放在了 npm 上，这样做的目的是为了让开发人员更方便的去下载使用 npm install jquery Node.js 能做什么 Web服务器后台 命令行工具 npm(node) git(c 语言) hexo(node) …… 游戏服务器/接口服务器 对于前端开发工程师来讲，接触 node 最多的是它的命令行工具 自己写的不多，主要是使用别人第三方开发的 webpack gulp npm 预备知识 HTML CSS JavaScript 简单的命令行操作 一些资源 官方API文档：http://nodejs.org/dist/latest-v6/docs/api/ CNODE社区：http://cnodejs.org 《深入浅出Node.js》 朴灵 偏理论，几乎没有任何实战性内容 理解底层原理有帮助 《Node.js 权威指南》API 讲解 学习 Node.js 你可以学到 B/S 编程模型 Browser-Server back-end 任何服务器技术这种BS编程模型都是一样的，和语言无关 Node 只是一个工具 模块化编程 RequireJS SeaJS @import(&#39;文件路径&#39;) Node常用API 异步编程 Express 开发框架","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"听，这是威廉·布莱克","slug":"听，这是威廉·布莱克","date":"2019-06-30T06:39:10.000Z","updated":"2019-07-09T02:48:16.105Z","comments":true,"path":"2019/06/30/听，这是威廉·布莱克/","link":"","permalink":"http://yoursite.com/2019/06/30/%E5%90%AC%EF%BC%8C%E8%BF%99%E6%98%AF%E5%A8%81%E5%BB%89%C2%B7%E5%B8%83%E8%8E%B1%E5%85%8B/","excerpt":"London ——William Blake伦敦 ——威廉布莱克 I wandered through each chartered street,Near where the chartered Thames does flow,A mark in every face I meet,Marks of weakness, marks of woe.我走过每条独占的街道，徘徊在独占的泰晤士河边，我看见每个过往的行人有一张衰弱、痛苦的脸。","text":"London ——William Blake伦敦 ——威廉布莱克 I wandered through each chartered street,Near where the chartered Thames does flow,A mark in every face I meet,Marks of weakness, marks of woe.我走过每条独占的街道，徘徊在独占的泰晤士河边，我看见每个过往的行人有一张衰弱、痛苦的脸。 In every cry of every man,In every infant’s cry of fear,In every voice, in every ban,The mind-forged manacles I hear:每个人的每声呼喊，每个婴孩害怕的号叫，每句话，每条禁令，都响着心灵铸成的镣铐。 How the chimney-sweeper’s cryEvery blackening church appals,And the hapless soldier’s sighRuns in blood down palace-walls.多少扫烟囱孩子的喊叫震惊了一座座熏黑的教堂，不幸兵士的长叹化成鲜血流下了宫墙。 But most, through midnight streets I hearHow the youthful harlot’s curseBlasts the new-born infant’s tear,And blights with plagues the marriage-hearse.最怕是深夜的街头又听年轻妓女的诅咒！它骇注了初生儿的眼泪，又用瘟疫摧残了婚礼丧车。","categories":[{"name":"诗和远方","slug":"诗和远方","permalink":"http://yoursite.com/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"}]}],"categories":[{"name":"bug汇总","slug":"bug汇总","permalink":"http://yoursite.com/categories/bug%E6%B1%87%E6%80%BB/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/categories/SpringMVC/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"},{"name":"WebService","slug":"WebService","permalink":"http://yoursite.com/categories/WebService/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/categories/MyBatis/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"},{"name":"Struts2","slug":"Struts2","permalink":"http://yoursite.com/categories/Struts2/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"},{"name":"XML","slug":"XML","permalink":"http://yoursite.com/categories/XML/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/categories/JDBC/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/%E6%B1%87%E7%BC%96/"},{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/categories/DataBase/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/categories/Tomcat/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"诗和远方","slug":"诗和远方","permalink":"http://yoursite.com/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"}],"tags":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"汇总","slug":"汇总","permalink":"http://yoursite.com/tags/%E6%B1%87%E6%80%BB/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"WebService","slug":"WebService","permalink":"http://yoursite.com/tags/WebService/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyaBtis","slug":"MyaBtis","permalink":"http://yoursite.com/tags/MyaBtis/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"}]}